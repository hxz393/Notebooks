# 软件管理

## 编译程序

编译程序就是将源代码编译成机器语言生成一个可执行二进制程序.

在Linux中使用configure命令来对系统环境进行检测收集生成Makefile文件,make命令根据makefile文件配置来对源文件进行编译生成可执行二进制程序.

简单来说通过源代码安装程序步骤如下:

1. 将包含源代码的压缩包从网上下下来;
2. 解压压缩包;
3. 用gcc进行源代码编译,产生目标文件object files;
4. 以gcc进行函数库,主副程序的链接,形成二进制文件;
5. 将二进制文件及相关配置文件安装到指定目录.

编译安装需要用到的程序有:gcc,make,autoconfig,还有相关Library和Include文件.一般可以用`yum groupinstall "Development Tools"`命令来安装所需套件.

### 单一程序

写一个简单的c语言源代码进行编译测试:

```sh
[root@101c7 ~]# vi hello.c
#include <stdio.h>
int main (void)
{
        printf("hello\n");
}
"hello.c" [New] 5L, 58C written
```

开始用gcc编译后运行:

```sh
[root@101c7 ~]# gcc hello.c 
[root@101c7 ~]# ll
total 20
-rw-------. 1 root root 1260 Sep  8 01:38 anaconda-ks.cfg
-rwxr-xr-x. 1 root root 8360 Sep 21 20:33 a.out
-rw-r--r--. 1 root root   59 Sep 21 20:32 hello.c
[root@101c7 ~]# ./a.out 
hello
```

在没有加入参数运行gcc编译时,可执行文件名为a.out.可以使用-o参数来指定输出文件名为hello.exe:

```sh
[root@101c7 ~]# gcc -c hello.c
[root@101c7 ~]# gcc -o hello.exe hello.o
[root@101c7 ~]# ./hello.exe 
hello
```

### 主副程序链接

如果在主程序里又调用了另一个副程序,例如新建一个world.c,再到hello.c调用它:

```sh
[root@234c8 ~]# vi world.c
#include <stdio.h>
void world (void)
{
        printf("world!\n");
}
"world.c" [New] 5L, 62C written
[root@234c8 ~]# vi hello.c 
#include <stdio.h>
int main (void)
{
        printf("hello ");
        world ();
}
"hello.c" 6L, 69C written
```

同样执行编译,最终生成二进制文件helloworld:

```sh
[root@234c8 ~]# gcc -c hello.c world.c 
[root@234c8 ~]# ll
total 20
-rw-------. 1 root root 1260 Sep  8 01:38 anaconda-ks.cfg
-rw-r--r--. 1 root root   69 Sep 21 20:43 hello.c
-rw-r--r--. 1 root root 1560 Sep 21 20:44 hello.o
-rw-r--r--. 1 root root   62 Sep 21 20:42 world.c
-rw-r--r--. 1 root root 1488 Sep 21 20:44 world.o
[root@234c8 ~]# gcc -o helloworld hello.o world.o
[root@234c8 ~]# ./helloworld 
hello world!
```

这个生成的二进制文件helloworld包含了两个源代码里的内容.如果修改了源文件world.c内容,只需要重新编译world.c文件,将新的world.o和hello.o链接制作出修改过后的二进制可执行文件.

### 调用外部函数库

如果调用的是系统函数库,直接在源文件里include进来.也可以使用-I参数来指定include文件位置:

```sh
[root@234c8 ~]# vi sin.c
#include <stdio.h>
#include <math.h>
int main (void)
{
        float value;
        value = sin (3/2);
        printf ("%f\n",value);
}
"sin.c" 8L, 115C written
[root@234c8 ~]# gcc sin.c -I/usr/include     
[root@234c8 ~]# ./a.out 
0.841471
```

如果要指定函数库位置可以使用-L参数.另外-参数表示加入某函数库,m代表libm.so函数库:

```sh
[root@234c8 ~]# gcc sin.c -lm -L/lib -L/lib64
```

### 创建Makefile

Makefile文件作用为简化整个编译流程.可以手动创建一个Makefile来测试下:

```sh
[root@234c8 ~]# vi makefile
main: hello.o world.o
        gcc -o main hello.o world.o
"makefile" [New] 2L, 51C written
[root@234c8 ~]# make
cc    -c -o hello.o hello.c
cc    -c -o world.o world.c
gcc -o main hello.o world.o
[root@234c8 ~]# ll
total 40
-rw-r--r--. 1 root root   69 Sep 21 20:43 hello.c
-rw-r--r--. 1 root root 1560 Sep 21 21:05 hello.o
-rwxr-xr-x. 1 root root 8472 Sep 21 21:05 main
-rw-r--r--. 1 root root   51 Sep 21 21:05 makefile
-rw-r--r--. 1 root root   62 Sep 21 20:42 world.c
-rw-r--r--. 1 root root 1488 Sep 21 21:05 world.o
[root@234c8 ~]# make
make: `main' is up to date.
[root@234c8 ~]# ./main 
hello world!
```

如果更新了源文件,只需要再次执行make命令就可以将生成的可执行文件更新.

当有两个以上执行动作时,例如编译完成后删除生成的.o文件,可以直接在后面接自定义阶段名:

```sh
[root@234c8 ~]# vi makefile 
main: hello.o world.o
        gcc -o main hello.o world.o
clean:
        rm -f hello.o world.o
"makefile" 4L, 81C written
[root@234c8 ~]# make clean
rm -f hello.o world.o
```

运行时,在make后面接阶段名即可执行那一阶段定义的命令.

默认不接参数是执行main中命令,想要先执行mian段再执行clean段,可以把两个阶段名都写出来:

```sh
[root@234c8 ~]# make main clean
cc    -c -o hello.o hello.c
cc    -c -o world.o world.c
gcc -o main hello.o world.o
rm -f hello.o world.o
```

在Makefile中可以使用变量来简化内容,例如将hello.o world.o定义为OBJS:

```sh
[root@234c8 ~]# vi makefile 
OBJS = hello.o world.o
main: ${OBJS}
        gcc -o main ${OBJS}
clean:
        rm -f ${OBJS}
```

另外可以用$@代表目前的target(也就是main)

### 从源代码安装程序

通常建议源代码放在/usr/local/src下,软件安装到/usr/local下面.

一般从网上下载的源码包安装实际操作步骤如下:

1. 取得原始文件,一般是tar压缩包;
2. 将tar解压缩,读取里面的INSTALL或README等文档;
3. 根据文档的要求安装好一些依赖软件;
4. 创建makefile,一般用./configure脚本来检测系统与相关软件属性;
5. 运行make clean; make以makefile作为配置来编译;
6. 运行make install将目标文件安装到指定路径.

以上每个步骤都必须执行成功,才能进行下一步骤.

下面以安装NTP举例.先到官网:http://www.ntp.org/downloads.html找到最新的安装包用wget下载:

```sh
[root@234c8 ~]# cd /usr/local/src
[root@234c8 src]# wget http://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p15.tar.gz
100%[=================================================================>] 7,015,970   23.5KB/s   in 6m 2s  

2021-09-21 22:14:23 (18.9 KB/s) - ‘ntp-4.2.8p15.tar.gz’ saved [7015970/7015970]
```

验证下载的tar文件MD5值是否正确:

```sh
[root@234c8 src]# wget http://www.eecis.udel.edu/~ntp/ntp_spool/ntp4/ntp-4.2/ntp-4.2.8p15.tar.gz.md5
100%[=================================================================>] 61          --.-K/s   in 0s      

2021-09-21 23:01:20 (9.29 MB/s) - ‘ntp-4.2.8p15.tar.gz.md5’ saved [61/61]
[root@234c8 src]# md5sum ntp-4.2.8p15.tar.gz --check ntp-4.2.8p15.tar.gz.md5 
md5sum: ntp-4.2.8p15.tar.gz: no properly formatted MD5 checksum lines found
ntp-4.2.8p15.tar.gz: OK
```

将其解压并阅读README文件:

```sh
[root@234c8 src]# tar -zxv -f ntp-4.2.8p15.tar.gz 
ntp-4.2.8p15/lib/isc/ia64/include/isc/
ntp-4.2.8p15/lib/isc/ia64/include/isc/atomic.h
ntp-4.2.8p15/lib/isc/alpha/include/
ntp-4.2.8p15/lib/isc/alpha/include/isc/
ntp-4.2.8p15/lib/isc/alpha/include/isc/atomic.h
[root@234c8 src]# cd ntp-4.2.8p15 ; less README
Submit patches, bug reports, and enhancement requests via

                        http://bugs.ntp.org
```

说明文件里指明了每个文件的意义,接着使用./configure创建makefile.加入--prefix参数指定最终安装位置:

```sh
[root@234c8 ntp-4.2.8p15]# ./configure --prefix=/usr/local/ntp --enable-all-clocks --enable-parse-clocks
config.status: creating Makefile
config.status: creating config.h
config.status: creating evconfig-private.h
config.status: evconfig-private.h is unchanged
config.status: executing depfiles commands
config.status: executing libtool commands
[root@234c8 ntp-4.2.8p15]# cat Makefile | grep /usr/local/ntp
NTP_KEYSDIR = /usr/local/ntp/etc
PERLLIBDIR = /usr/local/ntp/share/ntp/lib
prefix = /usr/local/ntp
```

最用使用make来安装:

```sh
[root@234c8 ntp-4.2.8p15]# make clean; make
make[2]: Entering directory `/usr/local/src/ntp-4.2.8p15'
make[2]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
make[1]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
[root@234c8 ntp-4.2.8p15]# make check
make[2]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
make[1]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
[root@234c8 ntp-4.2.8p15]# make install
Installing stand-alone HTML documentation
make[3]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
make[2]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
make[1]: Leaving directory `/usr/local/src/ntp-4.2.8p15'
[root@234c8 ntp-4.2.8p15]# ll /usr/local/ntp/
total 0
drwxr-xr-x. 2 root root 189 Sep 21 22:26 bin
drwxr-xr-x. 2 root root   6 Sep 21 22:26 libexec
drwxr-xr-x. 2 root root   6 Sep 21 22:26 sbin
drwxr-xr-x. 5 root root  39 Sep 21 22:26 share
```

使用patch命令来对源码进行更新后,还需要再次编译才能生效.



## 函数库管理

在Linux下依据函数库是否被编译到程序内部分为动态与静态函数库:

- 静态(Static): 一般扩展名为.a,在编译时直接整合到执行程序中.
- 动态(Dynamic): 扩展名为.so,在编译时程序只有一个指向(Pointer)位置,需要用到时才会去读取.

现在软件偏向使用动态函数库,这样方便升级函数库后不需重新编译程序.

### 将函数库常驻内存

可以将常用的动态函数库载入内存中,这样程序调用函数库时比从硬盘读取速度快.方法如下:

- 在/etc/ld.so.conf里写明要读入内存中的函数库目录;
- 利用ldconfig将ld.so.conf中配置的函数库读入内存;
- 同时也将数据记录一份在/etc/ld.so.cache这个文件中.

假设要把mysql数据库的函数库载入内存(实际上系统默认已经这么做了):

```sh
[root@234c8 ~]# vi /etc/ld.so.conf.d/mariadb-x86_64.conf 
/usr/lib64/mysql
[root@234c8 ~]# ldconfig
[root@234c8 ~]# ldconfig -p | grep mysql
        libmysqlclient.so.18 (libc6,x86-64) => /usr/lib64/mysql/libmysqlclient.so.18

```

### 程序的动态函数库解析

可以使用ldd命令来查询,例如查询df命令使用的动态函数库:

```sh
[root@234c8 ~]# ldd /usr/bin/df
        linux-vdso.so.1 =>  (0x00007ffe7de99000)
        libc.so.6 => /lib64/libc.so.6 (0x00007fec1f049000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fec1f417000)
```

也可以继续来ldd来查询某个函数的相关函数:

```sh
[root@234c8 ~]# ldd -v /lib64/libc.so.6 
        /lib64/ld-linux-x86-64.so.2 (0x00007f894f632000)
        linux-vdso.so.1 =>  (0x00007ffecdfd8000)

        Version information:
        /lib64/libc.so.6:
                ld-linux-x86-64.so.2 (GLIBC_2.3) => /lib64/ld-linux-x86-64.so.2
                ld-linux-x86-64.so.2 (GLIBC_PRIVATE) => /lib64/ld-linux-x86-64.so.2
```

这个命令可以用来检查程序安装时的依赖性.



## 软件安装

通常不同的分发商会将一些软件编译好成二进制,通过软件管理平台提供给用户.Fedora/CentOS系列使用RPM软甲管理机制与yum线上更新模式,Debian使用dpkg软件管理机制与APT线上更新模式.





## 