# 磁盘操作

## 磁盘查询

主要是df这个命令,经常用来查询系统中磁盘剩余空间.比如发现根目录/满了,说明系统危险了.

### 查询磁盘容量

使用df查看磁盘使用量,df读取的是在Superblock内的信息.

例如查看系统内所有的文件系统:

```sh
[root@101c7 /]# df -h
Filesystem               Size  Used Avail Use% Mounted on
devtmpfs                 1.9G     0  1.9G   0% /dev
tmpfs                    1.9G     0  1.9G   0% /dev/shm
tmpfs                    1.9G   12M  1.9G   1% /run
tmpfs                    1.9G     0  1.9G   0% /sys/fs/cgroup
/dev/mapper/centos-root   17G  2.1G   15G  13% /
/dev/sda1               1014M  187M  828M  19% /boot
tmpfs                    378M     0  378M   0% /run/user/0
/dev/sdb1                991M  1.3M  939M   1% /ext333
```

当查询目标是目录或文件时,df会自动分析该目录所在分区,实际看到的是分区容量信息.

将所有特殊文件格式和名称(例如内存挂载点/proc)都列出来,可以使用-aT参数:

```sh
[root@101c7 ext333]# df -aT
Filesystem              Type        1K-blocks    Used Available Use% Mounted on
sysfs                   sysfs               0       0         0    - /sys
proc                    proc                0       0         0    - /proc
/dev/mapper/centos-root xfs          17811456 2724256  15087200  16% /
/dev/sda1               xfs           1038336  190536    847800  19% /boot
/dev/mapper/VG400-LV400 ext3           190145   63472    117934  35% /ext333
```

查询各分区中可用inode数量:

 ```sh
 [root@101c7 /]# df -ih
 Filesystem              Inodes IUsed IFree IUse% Mounted on
 /dev/mapper/centos-root   8.5M   46K  8.5M    1% /
 /dev/sda1                 512K   335  512K    1% /boot
 tmpfs                     472K     1  472K    1% /run/user/0
 /dev/sdb1                  64K    13   64K    1% /ext333
 ```

### 列出分区信息

可以使用命令lsblk来查询所有储存设备.

例如查看当前系统下所有磁盘与分区情况:

```sh
[root@101c7 ext333]# lsblk -i
NAME                 MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda                    8:0    0   20G  0 disk 
|-sda1                 8:1    0    1G  0 part /boot
`-sda2                 8:2    0   19G  0 part 
  |-centos-root      253:0    0   17G  0 lvm  /
  `-centos-swap      253:1    0    2G  0 lvm  [SWAP]
```

其中MAJ:MIN代表主要:次要设备代码,RM标记是否为可移动(removable)设备,RO为是否以只读挂载.

也可以只单独查询某个磁盘,用-p参数显示分区全名:

```sh
[root@101c7 ext333]# lsblk -ip /dev/sda
NAME                        MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
/dev/sda                      8:0    0  20G  0 disk 
|-/dev/sda1                   8:1    0   1G  0 part /boot
`-/dev/sda2                   8:2    0  19G  0 part 
  |-/dev/mapper/centos-root 253:0    0  17G  0 lvm  /
  `-/dev/mapper/centos-swap 253:1    0   2G  0 lvm  [SWAP]
```

UUID(Universally Unique Identifier)是全域单一识别码,也可以用UUID来挂载设备.使用blkid命令来查询

```sh
[root@101c7 ext333]# blkid
/dev/mapper/centos-root: UUID="bb5b6906-0dff-46c4-832e-1701522802e6" TYPE="xfs" 
/dev/sda2: UUID="0lYfzD-6Mqj-AtC4-Jgf1-LGpk-ODIk-xbJIa7" TYPE="LVM2_member" 
```



## 磁盘分区

如果是MBR分区表使用fdisk分区,GPT分区使用gdisk分区.两种工具在使用方法上没有区别.这里使用fdisk演示.

### 查看分区

例如查看系统内的所有分区:

 ```sh
 [root@101c7 ext333]# fdisk -l
 Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
 Units = sectors of 1 * 512 = 512 bytes
 Sector size (logical/physical): 512 bytes / 512 bytes
 I/O size (minimum/optimal): 512 bytes / 512 bytes
 Disk label type: dos
 Disk identifier: 0x000a3a75
 
    Device Boot      Start         End      Blocks   Id  System
 /dev/sda1   *        2048     2099199     1048576   83  Linux
 /dev/sda2         2099200    41943039    19921920   8e  Linux LVM
 
 Disk /dev/mapper/centos-root: 18.2 GB, 18249416704 bytes, 35643392 sectors
 Units = sectors of 1 * 512 = 512 bytes
 Sector size (logical/physical): 512 bytes / 512 bytes
 I/O size (minimum/optimal): 512 bytes / 512 bytes
 
 
 Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors
 Units = sectors of 1 * 512 = 512 bytes
 Sector size (logical/physical): 512 bytes / 512 bytes
 I/O size (minimum/optimal): 512 bytes / 512 bytes
 ```

由上页可见sda分了两个区,其中sda可做启动引导

对新增的磁盘sdb进行操作:

```sh
[root@101c7 ext333]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.


Command (m for help): 
```

进入fdisk后输入m可以查看帮助.常用命令有:d删除分区,n新增分区,p显示分区表,w写入分区信息并退出.

先看看分区状态:

```sh
Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x2de15e6d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048     2097151     1047552   83  Linux
```

由上表中可以看到:磁盘大小1073MB,扇区数2097152,每个扇区大小512Bytes,分区开始扇区号2048,截止扇区号2097151,block数(1KB为单位)1047552.

### 删除分区

假设要删除sdb1分区,在等待命令页面输入d会提示要删除的分区编号(sdb后面带的数字):

```sh
Command (m for help): d
Selected partition 1
Partition 1 is deleted
```

再次查看分区已经被删除了,保存退出:

```sh
Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x2de15e6d

   Device Boot      Start         End      Blocks   Id  System

Command (m for help): w
The partition table has been altered!
```

### 新增分区

输入n以后会进入新建分区交互界面:

1. 选择新增的分区类型是主分区p;
2. 设置为4号;
3. 起始扇区号采用默认2048;
4. 结束扇区号可以输入扇区号也可以输入大小,这里输入+100M大小

```sh
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Using default response p
Partition number (1-4, default 1): 4
First sector (2048-2097151, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-2097151, default 2097151): +100M
Partition 4 of type Linux and of size 100 MiB is set
```

再新增一个200M大小的扩展分区:

```sh
Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): e
Partition number (1-3, default 1): 1
First sector (206848-2097151, default 206848): 
Using default value 206848
Last sector, +sectors or +size{K,M,G} (206848-2097151, default 2097151): +200M
Partition 1 of type Extended and of size 200 MiB is set
```

完成后输入p查看状态:

```sh
Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x951d99c8

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1          206848      616447      204800    5  Extended
/dev/sdb4            2048      206847      102400   83  Linux

Partition table entries are not in disk order
```

可以看到有个主分区名字为sdb4,扩展分区名为sdb1,是我们手动设定的样子.

在扩展分区上建立个80M大小的逻辑分区,选择类型时输入l,系统会自动分配分区号:

```sh
Command (m for help): n
Partition type:
   p   primary (1 primary, 1 extended, 2 free)
   l   logical (numbered from 5)
Select (default p): l
Adding logical partition 5
First sector (208896-616447, default 208896): 
Using default value 208896
Last sector, +sectors or +size{K,M,G} (208896-616447, default 616447): +80M
Partition 5 of type Linux and of size 80 MiB is set
```

完成后输入w保存更改并退出:

```sh
Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
```

提示说要重启让改动生效,可以使用partprobe命令让内核重新扫描分区表:

```sh
[root@101c7 ext333]# partprobe -s
/dev/sda: msdos partitions 1 2
/dev/sdb: msdos partitions 1 2 3 4
/dev/sdc: msdos partitions 1
/dev/sr0: msdos partitions 2
```

下面展示使用gdisk制作一个500MB大小GPT分区的过程:

```sh
[root@101c7 ext333]# gdisk /dev/sdd
GPT fdisk (gdisk) version 0.8.10

Command (? for help): n
Partition number (1-128, default 1): 1
First sector (34-2097118, default = 2048) or {+-}size{KMGTP}: 
Last sector (2048-2097118, default = 2097118) or {+-}size{KMGTP}: +500MB
Current type is 'Linux filesystem'
Hex code or GUID (L to show codes, Enter = 8300): 
Changed type of partition to 'Linux filesystem'

Command (? for help): w

Final checks complete. About to write GPT data. THIS WILL OVERWRITE EXISTING
PARTITIONS!!

Do you want to proceed? (Y/N): y
OK; writing new GUID partition table (GPT) to /dev/sdd.
The operation has completed successfully.
[root@101c7 ext333]# partprobe -s
/dev/sda: msdos partitions 1 2
/dev/sdb: msdos partitions 1 2 3 4
/dev/sdc: msdos partitions 1
/dev/sdd: gpt partitions 1
/dev/sr0: msdos partitions 2
```

### 格式化分区

建立分区后要格式化分区才可使用,格式化通过mkfs类命令操作.

将sdb4格式化成ext3文件系统:

```sh
[root@101c7 ~]# mkfs -t ext3 /dev/sdb4 
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
25688 inodes, 102400 blocks
5120 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=67371008
13 block groups
8192 blocks per group, 8192 fragments per group
1976 inodes per group
Superblock backups stored on blocks: 
        8193, 24577, 40961, 57345, 73729

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done
```

如果要指定label,block大小,inode数量等参数,需要使用mke2fs命令.

例如将sdb4设定卷标boss,block大小2048,每8192bytes分配一个inode后格式化成ext3文件系统:

```sh
[root@101c7 ~]# mke2fs -j -L "boss" -b 2048 -i 8192 /dev/sdb4
```

用mkfs.xfs格式化xfs文件系统,要设定具体分区数值可用-d参数.指定储存区群组数量为16并强制格式化sdd1:

```sh
[root@101c7 ext333]# mkfs.xfs -f -d agcount=16 /dev/sdd1
meta-data=/dev/sdd1              isize=512    agcount=16, agsize=8000 blks
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   blocks=128000, imaxpct=25
         =                       sunit=0      swidth=0 blks
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
log      =internal log           bsize=4096   blocks=855, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   blocks=0, rtextents=0
```



## 磁盘工具

主要包括一些读写性能测试,文件系统修复等工具

### Ext磁盘扫描

Ext文件系统可使用fsck来对磁盘进行扫描,检查文件系统错误.通常情况下只有出现问题才使用这个命令.

例如进入到单用户模式下,被检查的分区务必不可挂载到系统上,否则可能造成部分文件系统损坏.

可用参数:

| 选项 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| -C   | 检验过程中显示进度                                           |
| -f   | 强制检查,将所有状态为clean的扇区也纳入检查范围               |
| -D   | 针对文件系统下的目录进行优化配置                             |
| -p   | 自动修复文件系统存在的问题                                   |
| -b   | 接superblock位置,用来恢复主superblock.一般备份在1K=8193/2K=16384/4k=32768位置 |
| -c   | 对文件系统进行坏块检查,并添加到坏块列表中.                   |

检查sdb4分区:

```sh
[root@101c7 ~]# fsck -C -f /dev/sdb4
fsck from util-linux 2.23.2
e2fsck 1.42.9 (28-Dec-2013)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure                                           
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
boss: 11/12800 files (0.0% non-contiguous), 5076/51200 blocks
```

使用备份恢复sdb4损坏的superblock:

```sh
[root@101c7 ext333]# fsck.ext3 -b 32768 /dev/sdb4
```

### Xfs磁盘扫描

xfs文件系统扫描使用xfs_repair工具.可用选项:

| 选项 | 说明                                             |
| ---- | ------------------------------------------------ |
| -f   | 后面接文件文件而不是磁盘                         |
| -n   | 单纯检查并不修改文件系统的任何数据               |
| -d   | 通常用在救援模式下面对根目录进行检查与修复的动作 |

修复时同样要求先卸载目标分区,例如检查/dev/sdd1:

```sh
[root@101c7 ext333]# xfs_repair /dev/sdd1
Phase 1 - find and verify superblock...
Phase 2 - using internal log
Phase 3 - for each AG...
Phase 4 - check for duplicate blocks...
Phase 5 - rebuild AG headers and trees...
Phase 6 - check inode connectivity...
Phase 7 - verify and correct link counts...
done
```

### 坏道扫描

badblocks命令用来检测硬盘扇区有没有坏道.其实等于mke2fs -c在进行格式化时处理磁盘表面的读取测试.

例如检查sdb4分区:

 ```sh
 [root@101c7 ~]# badblocks -sv /dev/sdb4
 Checking blocks 0 to 102399
 Checking for bad blocks (read-only test): done                                                 
 Pass completed, 0 bad blocks found. (0/0/0 errors)
 ```

### 修改设备代码

有时需要手动处理设备文件,可以使用mknod命令来修改设备代码.

可修改的设备种类有b(外部储存,移动硬盘),c(外部输入,鼠标),p(FIFO文件).

常见磁盘设备代码如下:

| 磁盘文件名 | Major | Minor |
| ---------- | ----- | ----- |
| /dev/sda   | 8     | 0-15  |
| /dev/sdb   | 8     | 16-31 |
| /dev/loop0 | 7     | 0     |
| /dev/loop1 | 7     | 1     |

例如创建sdb5的设备代码Maj:Min为8,21:

```sh
[root@101c7 ~]# mknod /dev/sdb5 b 8 21; ll /dev/sdb5
brw-rw----. 1 root disk 8, 21 Sep 10 04:08 /dev/sdb5
```

### 修改分区卷标

可以使用e2label来修改ext文件系统卷标(Label),卷标类似与Win中的"本地磁盘".

例如修改sdb4的卷标为"P1":

```sh
[root@101c7 ~]# e2label /dev/sdb4 "P1"
[root@101c7 ~]# dumpe2fs -h /dev/sdb4 | grep name
dumpe2fs 1.42.9 (28-Dec-2013)
Filesystem volume name:   P1
```

也可使用tune2fs命令来修改:

```sh
[root@101c7 ext333]# tune2fs -L P2 /dev/sdb4
```

### 修改UUID

XFS文件系统使用UUID作为标识符,可以使用xfs_admin命令修改UUID和Label.

例如修改sdd1的Label name为xfs1:

```sh
[root@101c7 ext333]# xfs_admin -L xfs1 /dev/sdd1
writing all SBs
new label = "xfs1"
```

修改UUID需要先生成UUID号码,可以使用uuidgen命令生成,然后再设置到sdd1上:

```sh
[root@101c7 ext333]# xfs_admin -U $(uuidgen) /dev/sdd1
Clearing log and setting UUID
writing all SBs
new UUID = c96b6650-756a-4496-bf26-6e7286c55891
```



