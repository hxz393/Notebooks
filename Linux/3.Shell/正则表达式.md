# 正则表达式

## 正则表达式定义

正则表达式就是处理字符串的方法,以行为单位来进行字符串的处理行为,正则表达式通过一些特殊符号的辅助,让用户轻易达到查找,删除,替换某特定字符串的处理程序.

基础正则表达式(BRE)和扩展正则表达式(ERE)的区别在于支持的元字符不同:

- **BRE支持的元字符**:^ $ . * [ ]
- **ERE支持的元字符**:^ $ . * [ ] + ( ) { } ? |



## 元字符

元字符要代变字符串意思时必须用转义字符\转义:

| 元字符 | 名称     | Unicode值 | 作用                 |
| ------ | -------- | --------- | -------------------- |
| .      | 句点     | U+002E    | 匹配任意字符         |
| \      | 反斜线   | U+005C    | 对字符转义           |
| \|     | 竖线符   | U+007C    | 选择操作(或)         |
| ^      | 脱字符   | U+005E    | 行起始锚位符         |
| $      | 美元符   | U+0024    | 行结束锚位符         |
| ?      | 问号     | U+003F    | 匹配零次或一次的量词 |
| *      | 星号     | U+002A    | 匹配零次或多次的量词 |
| +      | 加号     | U+002B    | 匹配一次或多次的量词 |
| [      | 左方括号 | U+005B    | 字符组起始           |
| ]      | 右方括号 | U+005D    | 字符组结束           |
| {      | 左花括号 | U+007B    | 量词或代码块起始     |
| }      | 右花括号 | U+007D    | 量词或代码块结束     |
| (      | 左括号   | U+0028    | 分组起始             |
| )      | 右括号   | U+0029    | 分组结束             |



## 行的起始 ^和结束 $

脱字符号**^**匹配一行的**开始****处空字符**,美元符号**$**匹配一行的**结尾****处空字符**.

单个^匹配所有行.

两个字符一起^$匹配空行.

例如去除配置文件中的空行和以#开头的注释行:

```sh
[root@101c7 sdb4m]# grep -v '^$' a.cfg | grep -v '^#'
auth --enableshadow --passalgo=sha512
cdrom
```



## 字符组 []

中括号[]表示字符组,里面匹配任意字符,字符组**只能匹配单个字符.**



## 字符组 [ - ]

在字符组内部连字符 - 表示一个范围,**只有在字符组内部才是元字符**,因此-不需要转义.

如果 - 是[]内第一个字符,表明匹配-的本意,而不是作为连接符用.

例如匹配数字和%:

```sh
[root@101c7 sdb4m]# grep '[0-9%]' a.cfg 
auth --enableshadow --passalgo=sha512
lang en_US.UTF-8
%packages
%end
```



## 排除型字符组 [^]

[^ ]列出不希望匹配的字符,比如[^x]表示匹配一个不等于x的字符.

并不能匹配空字符.



## 匹配任意字符 .

元字符点号 . 用来匹配除换行符之外任意一个字符,在**字符组内部**比如[1.3]中不是元字符



## 匹配任意子表达式 |

要表达或的意思用元字符竖号 |,表达式用小括号()括起来.

例如匹配出pwpolicy为root和user和luks用户的配置:

```sh
[root@101c7 sdb4m]# grep -E 'pwpolicy\s(root|user|luks)' a.cfg 
pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
```



## 单词分界符 \< 和 \>

\<单a 表示匹配以"单a"开头的单词;

尾a\> 表示匹配以"尾a"结束的单词;

\<单尾\> 表示匹配完整单词"单尾".

例如分别搜索出有以empty开头或结尾单词所在行:

```sh
[root@101c7 sdb4m]# grep -E '\<empty' a.cfg 
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
[root@101c7 sdb4m]# grep -E 'empty\>' a.cfg 
pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty
pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty
```



## 可选项元素 ?

用问号**?**表示可选项,把它加在一个字符后面表示此处容许出现这个字符,不过它的出现并非匹配成功的必要条件,它只作用于之前紧邻的元素,**匹配0到1次**.可使用的语法如下:

| **语法** | **描述**                 |
| -------- | ------------------------ |
| ??       | 懒惰匹配零次或一次(可选) |
| +?       | 懒惰匹配一次或多次       |
| *?       | 懒惰匹配零次或多次       |
| {n}?     | 懒惰匹配n次              |
| {n,}?    | 懒惰匹配n次或多次        |
| {m,n}?   | 懒惰匹配m至n次           |

例如匹配路径\bin或\sbin:

```sh
[root@101c7 sdb4m]# grep -E '\/s?bin:' b.cfg 
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
```



## 重复单次 +和多次 *

加号**+**表示之前紧邻的元素匹配**1次到多次**.

星号*****表示之前紧邻的元素匹配**0到任意次数**.

疑问号?星号*和加号+统称为量词,因为他们限定了所作用元素的匹配次数.

?能匹配一个空格,*能匹配任意多空格,他们永远不会匹配失败,+匹配不到会报告失败

语法如下:

| **语法** | **描述**                   |
| -------- | -------------------------- |
| ?+       | 占有式匹配零次或一次(可选) |
| ++       | 占有式匹配一次或多次       |
| *+       | 占有式匹配零次或多次       |
| {n}+     | 占有式匹配n次              |
| {n,}+    | 占有式匹配n次或更多次      |
| {m,n}+   | 占有式匹配m至n次           |



## 指定匹配次数 {}

大括号内接数字,用来限制找到的字符数量.

例如查找3位数字的UID:

```sh
[root@101c7 sdb4m]# grep -E '[0-9]{3}' b.cfg 
games:x:12:100:games:/usr/games:/sbin/nologin
```

可以通过{a,b}来限定范围,例如查找6到8位数长的号码:

```sh
[root@101c7 sdb4m]# grep -E '[0-9]{6,8}' b.cfg
```

也可以只写一半区间,例如查找11位长度以上的号码:

```sh
[root@101c7 sdb4m]# grep -E '[0-9]{11,}' b.cfg
```



## 分组 ()

分组功能可用功能在各种编程语言下调用形式不同.

例如查找id和gid都为89或99的用户:

```sh
[root@101c7 sdb4m]# grep -E '((89|99):)\1' b.cfg 
nobody:x:99:99:Nobody:/:/sbin/nologin
postfix:x:89:89::/var/spool/postfix:/sbin/nologin
```

注意分组内容一定是用小括号括起来.



## 非捕获分组 (?:)

在圆括号内以?:开头,这个圆括号内的内容不会被捕获.在grep中不可用.



## 反向引用 \

也叫捕获分组或向后引用,匹配与表达式先前部分匹配的同样文本.需要用括号()包含分组

例如查找boo或Roo:

```sh
[root@101c7 sdb4m]# grep -E '(b|R)(o)\2' a.cfg 
# Run the Setup Agent on first boot
firstboot --enable
network  --bootproto=dhcp --device=ens33 --onboot=off --ipv6=auto --no-activate
# Root password
```



## 转义字符 \

如果需要匹配的字符本身就是元字符,需要用反斜杠\来转义,把元字符变成普通字符.

在字符组内部转义字符无效.

例如在文件内容中查找1.4:

```sh
[root@101c7 sdb4m]# grep -E '1.4' c.cfg 
1.4
1a4
[root@101c7 sdb4m]# grep -E '1\.4' c.cfg 
1.4
```



## 正前瞻 (?=)

grep中用得较少,一般用在编程中排除掉正前瞻内容作为匹配结果处理.例如正则表达式/bed(?=room)/只能匹配子串"bedroom",而子串"room"并不作为匹配结果返回,以进行后续处理.

例如匹配nochanges --,并要求后面接的参数为emptyok:

```sh
[root@101c7 sdb4m]# grep -P 'nochanges\s\-\-(?=emptyok)' a.cfg 
pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok
```



## 反前瞻 (?!)

匹配后面找不到含有给定前瞻模式的内容



## 正后顾 (?<=)

正后顾会查看左边的内容,这与正前瞻方向相反.



## 反后顾 (?<!)

反后顾会查看某个模式在从左至右的文本流的后面没有出现



## 字符简写式

不同类型正则表达式所支持的字符简写式不同,下表用B,E,P代表基础,扩展,Perl的支持状况:

| 字符简写式 | 描述                                                         | 支持情况 |
| ---------- | ------------------------------------------------------------ | -------- |
| \a         | 报警符                                                       | P        |
| \b         | 匹配一个单词边界,用法等同于单词分界符.                       | B E P    |
| \B         | 匹配非单词边界,单词中的元素                                  | B E P    |
| \d         | 数字字符,等同于[0-9]                                         | P        |
| \D         | 匹配除数字以外的所有字符                                     | P        |
| \f         | 换页符,等价于\x0c和\cL                                       | P        |
| \r         | 回车符,等价于\xd和\cM                                        | P        |
| \n         | 换行符,等价于\x0a和\cJ                                       | P        |
| \s         | 匹配空格 制表符(\t) 换行符(\n) 回车符(\r)                    | P        |
| \S         | 匹配所有文本内容,包括中文,不包含空格.等价[^\t\n\r]或[^\s]    | P        |
| \t         | 水平制表符,等价于\x09和\cI                                   | P        |
| \v         | 垂直制表符,等价于\xb和\cK                                    | P        |
| \w         | 匹配英文字母,数字和下划线,等同于[a-zA-Z0-9_]                 | B E P    |
| \W         | 匹配任何非ASCII字母字符,非数字以及非下划线字符.等同于[^A-Za-z0-9_] | B E P    |
| [\b]       | 退格字符                                                     | P        |
| \cx        | 匹配由x指明的控制字符,代码可参考控制字符表                   | P        |
| \uxxxx     | 字符的Unicode值,代码可参考控制字符表                         | P        |
| \dxxx      | 字符的十进制值                                               | P        |
| \oxxx      | 字符的八进制值                                               | P        |
| \x xx      | 字符的十六进制值                                             | P        |



## POSIX字符类

不同的编码格式下,可能造成正则输出结果不一样,例如LANG=zh_CN情况下a和A的编号是相邻的.

| 字符类     | 说明                                             |
| ---------- | ------------------------------------------------ |
| [:alnum:]  | 任何一个字母或数字,等价于[a-zA-Z0-9]             |
| [:alpha:]  | 任何一个字母,等价于[a-zA-Z]                      |
| [:blank:]  | 空格或制表符,等价于[\t ]                         |
| [:cntrl:]  | ASCII控制字符,ASCII0到31,再加上ASCII127          |
| [:digit:]  | 任何一个数字,等价于[0-9]                         |
| [:graph:]  | 和[:print:]一样,但不包括空格                     |
| [:lower:]  | 任何一个小写字母,等价于[a-z]                     |
| [:print:]  | 任何一个可打印字符                               |
| [:punct:]  | 既不属于[:alnum:]也不属于[:cntrl:]的任何一个字符 |
| [:space:]  | 任何一个空白字符,包括空格,等价于[^\f\n\r\t\v ]   |
| [:upper:]  | 任何一个大写字母,等价于[A-Z]                     |
| [:xdigit:] | 任何一个十六进制数字,等价于[a-fA-F0-9]           |



## 控制字符表

对照表如下:

| 控制字符 | Unicode值 | 简写 | 名称         |
| -------- | --------- | ---- | ------------ |
| c@*      | U+0000    | NUL  | 空字符       |
| \cA      | U+0001    | SOH  | 标题起始     |
| \cB      | U+0002    | STX  | 文本起始     |
| \cC      | U+0003    | ETX  | 文本结束     |
| \cD      | U+0004    | EOT  | 传输结束     |
| \cE      | U+0005    | ENQ  | 询问         |
| \cF      | U+0006    | ACK  | 确认         |
| \cG      | U+0007    | BEL  | 报警符       |
| \cH      | U+0008    | BS   | 退格符       |
| \cI      | U+0009    | HT   | 水平制表符   |
| \cJ      | U+000A    | LF   | 换行符       |
| \cK      | U+000B    | VT   | 垂直制表符   |
| \cL      | U+000C    | FF   | 换页         |
| \cM      | U+000D    | CR   | 回车符       |
| \cN      | U+000E    | SO   | 移出         |
| \cO      | U+000F    | SI   | 移入         |
| \cP      | U+0010    | DLE  | 数据链转义   |
| \cQ      | U+0011    | DC1  | 设备控制符一 |
| \cR      | U+0012    | DC2  | 设备控制符二 |
| \cS      | U+0013    | DC3  | 设备控制符三 |
| \cT      | U+0014    | DC4  | 设备控制符四 |
| \cU      | U+0015    | NAK  | 否定性确认   |
| \cV      | U+0016    | SYN  | 同步空闲     |
| \cW      | U+0017    | ETB  | 传输块结尾   |
| \cX      | U+0018    | CAN  | 取消         |
| \cY      | U+0019    | EM   | 介质结尾     |
| \cZ      | U+001A    | SUB  | 替换         |
| \c[      | U+001B    | ESC  | 转义         |
| \c\      | U+001C    | FS   | 信息分隔符四 |
| \c]      | U+001D    | GS   | 信息分隔符三 |
| \c^      | U+001E    | RS   | 信息分隔符二 |
| \c_      | U+001F    | US   | 信息分隔符一 |



## 示例

**匹配windows中空行**:

windows中空行是由CR+LR,回车+换行组成,如果单个\r\n匹配一行中末尾替换成空字符会把下一行内容拼上来.

\r\n\r\n

**匹配UNIX中空行**:

Linux系统中结尾只有LR换行符,两个换行符匹配一条空行

\n\n

**匹配HTML标签**:

<_a-zA-Z*>

</?_a-zA-Z*>

[^>]表示标签内容排除>

**匹配数字千位**:

(?<=\d)(?=(\d\d\d)+$)

