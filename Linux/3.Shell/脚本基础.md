# 脚本基础

## Shell Script定义

Shell Script就是利用shell的功能所写的一个程序,这个程序使用纯文本文件,将一些shell的语法与命令写在里面,搭配正则表达式,管道命令与数据流重定向等功能达到所想要的处理目的.

脚本编写注意事项:

- 命令执行时从上而下,从左到右地分析与执行;
- 命令参数之间的多个空白都会被忽略掉;
- 空白行会被忽略掉,包括[tab]也被视为空格;
- 如果读到一个Enter(CR),就尝试开始执行该命令;
- 一行内容太多,可使用\"[Enter]"来扩展至下一行;
- \#可以作为批注,任何#后面的内容都会被注释掉.



## 执行脚本

直接执行脚本需要对脚本拥有**r和x权限**,方式有下面几种:

- 可以通过绝对路径直接执行,比如/root/test.sh;
- 可以通过相对路径直接执行,比如./test.sh;
- 可以将脚本放置到PATH指定的目录内,如~/bin/内,输入test.sh就能直接执行;
- 以bash子进程来执行.例如 bash test.sh.以此方式执行test.sh只要有r的权限就能执行.
- 用source命令来执行脚本将直接在父进程中运行.例如 source test.sh.

直接执行脚本的方式会使用一个新的bash环境来执行脚本命令,也就是在子进程的bash内执行.这样子进程内的各项变量或操作在结束后不会传回到父进程中.

 

## 编写脚本

先以一个最简单的脚本作为范例:

```bash
#!/bin/bash
# Program:
#   This program shows "Hello Hell!" in your screen.
# History:
# 2046/1/1  Ass First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
echo -e 'Hello Hell! \a \n'
exit 0
```

执行命令:

```sh
[root@101c7 bin]# bash sh01.sh 
Hello Hell!  
```

逐行内容分析如下:

- **#!/bin/bash**

  声明这个脚本使用的shell名称.使这个脚本执行时能加载bash的相关环境配置文件(一般是~/.bashrc),并执行bash来使下面的命令能够执行.如果没有设置好这一行,脚本可能无法执行,因为系统无法判断需要使用什么shell来执行.

- **#开头的内容**

  除了第一行#!用来声明shell外,其他#开头的行都是批注作用.

- **主要环境变量的声明**

  建议将一些重要的环境变量设置好.除了PATH还有LANG.这样可以让程序在进行时可以直接执行一些外部命令,而不必写绝对路径.

- **主要程序部分**

  此处为echo命令.

- **告知执行结果**

  利用exit这个命令来让程序中断,并回传一个数值给系统.执行完脚本后使用echo $?命令可以显示0值.也可以利用exit n的功能自定义错误信息.



## 判断测试

使用test指令用于检查某个条件是否成立,它可以进行数值,字符和文件三个方面的测试.

文件类型检测参数如下,检测类型前会先检查文件是否存在:

| 参数 | 功能                     |
| ---- | ------------------------ |
| -e   | 文件名是否存在           |
| -f   | 文件类型是否为文件       |
| -d   | 文件类型是否为目录       |
| -b   | 文件是否为block设备      |
| -c   | 文件是否为character设备  |
| -S   | 文件是否为Socket文件     |
| -p   | 文件是否为FIFO(pipe)文件 |
| -L   | 文件是否为连接文件       |

文件的权限检测参数如下,也会先检查文件是否存在.root权限常有例外:

| 参数 | 功能                       |
| ---- | -------------------------- |
| -r   | 检测是否具有r权限          |
| -w   | 检测是否具有w权限          |
| -x   | 检测是否具有x权限          |
| -u   | 检测是否具有SUID属性       |
| -g   | 检测是否具有SGID属性       |
| -k   | 检测是否具有Sticky bit属性 |
| -s   | 检测文件是否为非空白文件   |

两个文件之间的比较参数如下,如test file1 -nt file2:

| 参数 | 功能                                                         |
| ---- | ------------------------------------------------------------ |
| -nt  | newer than缩写,判断file1是否比file2新                        |
| -ot  | older than缩写,判断file1是否比file2旧                        |
| -ef  | 判断file1与file2是否为统一文件,主要判定两个文件是否指向inode相同 |

整数之间的判定,例如test n1 -eq n2:

| 参数 | 功能                                 |
| ---- | ------------------------------------ |
| -eq  | 两数值相等(equal)                    |
| -ne  | 两数值不等(not equal)                |
| -gt  | n1大于n2(greater  than)              |
| -lt  | n1小于n2(less than)                  |
| -ge  | n1大于等于n2(greater  than or equal) |
| -le  | n1小于等于n2(less than  or equal)    |

判定字符串的数据,例如[ -z "${JAVA}" ]:

| 参数       | 功能                                                |
| ---------- | --------------------------------------------------- |
| -z string  | 判定字符串string是否为0,若string为空字符串返回true  |
| -n string  | 判定字符串string是否非0,若string为空字符串返回false |
| str1=str2  | 判定str1是否等于str2,相等返回true                   |
| str1!=str2 | 判定str1是否不等于str2,不相等返回true               |

多重条件判定,例如test -r file -a -x file:

| 参数 | 功能                                               |
| ---- | -------------------------------------------------- |
| -a   | 两个条件同时成立时才返回true                       |
| -o   | 任何一个条件成立时返回true                         |
| !    | 反向状态,例如test ! -e file,当file不存在时返回ture |

通常使用中括号[]来代替test进行数据判断,例如判断两个变量是否相等:

```sh
[root@101c7 bin]# [ "$HOME" == "$MAIL" ] || echo 'no'
no
```

中括号[]用作判断时:

- **中括号内每个组件都需要有空格来分隔**;
- **中括号内的变量最好都以双引号括起来**;
- **中括号内的常量最好都以单或双引号括起来**.



## 参数变量

如果脚本支持参数,那么脚本或命令名为\$0变量,后面参数从$​1开始赋值.

特殊的变量:

| 变量 | 说明                                    |
| ---- | --------------------------------------- |
| $#   | 代表输入的参数个数                      |
| $@   | 代表"$1","$2","$3"之意,每个变量是独立的 |
| $*   | 代表"$1c$2c$3",其中c为分隔符,默认是空格 |

在脚本中使用shift可以进行参数变量偏移.比如shift 3代表拿掉前3个参数变量.



## 逻辑判断

支持嵌套循环形式.

### if...then

**单条件判断的写法**:

```sh
if [ 条件判断式 ]; then
    条件成立时运行的命令;
fi
```

if后可以有多个条件判断式,用&&或||隔开代表And或Or

**多条件判断的写法**:

```sh
if [ 条件判断式1 ]; then
    条件判断式1成立时运行的命令;
elif [ 条件判断式2 ]; then
    条件判断式2成立时运行的命令;
else
    条件判断式都不成立时运行的命令;
fi
```

### case...esac

**基本写法如下:**

```sh
case $变量名称 in
    "第一个变量内容")
        程序段
        ;;
    "第二个变量内容")
        程序段
        ;;
    *)
        不符合所有条件的程序执行段
        exit 1
        ;;
esac
```

### 函数

可以使用function来定义函数,函数需要在调用前定义:

```sh
function 函数名(){
    程序段
}
```

函数同样可以在内部使用参数变量,例如0代表函数名,1代表第一个参数.

### 不定循环

**while do done**

条件成立时进行循环,基本写法:

```sh
while [ 判断式 ]
do
    程序段落
done
```

**until do done**

条件成立时终止循环,基本写法:

```sh
until [ 判断式 ]
do
    程序段落
done
```

### 固定循环

**for...do...done**

for语法用来表示已知次数的循环.in后面参数之间用空格隔开,基本语法:

```sh
for var in con1 con2 con3 ...
do
    程序段
done
```

可以用seq(sequence的缩写)来定义连续数字.比如定义循环范围1到10:

```sh
for nu in $(seq 1 10)
```

要定义连续字符可以写成echo {a..z}

可以使用自定义数值处理:

```sh
for ((初始值; 限制值; 执行步长))
```

| 参数     | 说明                                        |
| -------- | ------------------------------------------- |
| 初始值   | 直接以类似i=1设置好                         |
| 限制值   | 值在限制值范围内继续循环,例如i<=20          |
| 执行步长 | 每做一次循环时变量的变化范围,例如i=i+1(i++) |



## 调试脚本

可以使用bash的-n参数来检查脚本有无语法错误:

```sh
[root@101c7 bin]# bash -n sh11.sh 
sh11.sh: line 8: syntax error: unexpected end of file
```

没有错误什么也不会输出.有错误会显示错误所在行与类型.

使用-x参数将执行过程全部列出来:

```sh
[root@101c7 bin]# bash -x sh11.sh 
+ s=1
+ (( i=101 ))
+ (( i<=110 ))
+ s=101
+ (( i=i+2 ))
+ (( i<=110 ))
+ s=10403
```

带+开头的行表示命令串,实际输出没有+

