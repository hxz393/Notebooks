# 开机关机



## 内核模块管理

内核与内核模块在下面路径:

- 内核: /boot/vmlinuz

- 虚拟文件系统(RAM Disk): /boot/initramfs

- 内核模块: /lib/modules/version/kernel

- 内核源代码: /usr/src/linux

如果有操作系统不支持的新硬件要安装,可以重新编译内核,将硬件驱动加入进去.或者把硬件驱动编译成模块,在开机时载入.

### 内核模块依赖

在内核模块目录中通常分为以下几个子目录:

- arch: 与硬件平台有关的项目,如CPU的等级
- crypto: 内核所支持的加密技术,例如md5,des等
- drivers: 一些硬件的驱动程序,如网卡,显卡驱动等
- fs: 内核支持的文件系统,如vfat,nfs等
- lib: 一些函数库
- net: 与网络有关的各项协定数据,包括防火墙
- sound: 与声音有关模块

内核模块之间的依赖性检查通过/lib/modules/version/modules.dep来记录,可以使用depmod命令来加入已编译好的模块.例如要加入名为tp-413.ko网卡驱动到内核模块:

```sh
[root@101c7 ~]# cp tp-413.ko /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/net/
[root@101c7 ~]# depmod
```

执行depod命令后,程序会跑到内核模块目录,将全部模块分析一遍,将结果写入到modules.dep文件中.

### 内核模块查询

要查询内核以及加载的模块列表,可以使用lsmod命令:

```sh
[root@101c7 ~]# lsmod
Module                  Size  Used by
nf_conntrack_ftp       18478  0 
nf_conntrack          139264  1 nf_conntrack_ftp
snd_seq_midi           13565  0 
snd_seq_midi_event     14597  1 snd_seq_midi
```

结果会分别显示出模块名称,模块大小和模块被其他模块使用(Used by)的信息.

如果想要查询模块具体信息,可以使用modinfo命令.例如查询nf_conntrack_ftp模块:

```sh
[root@101c7 ~]# modinfo nf_conntrack_ftp
filename:       /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/net/netfilter/nf_conntrack_ftp.ko.xz
alias:          nfct-helper-ftp
alias:          ip_conntrack_ftp
description:    ftp connection tracking helper
author:         Rusty Russell <rusty@rustcorp.com.au>
license:        GPL
retpoline:      Y
rhelversion:    7.9
srcversion:     F21861D5AD43080B93CC4DD
depends:        nf_conntrack
intree:         Y
vermagic:       3.10.0-1160.41.1.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        4B:E3:B8:E9:52:F4:81:B2:62:51:AC:E4:66:9B:A7:99:71:D1:F1:AF
sig_hashalgo:   sha256
parm:           ports:array of ushort
parm:           loose:bool
```

从上面查询可以得到模块的文件位置,依赖的模块,还有模块的参数(parm).

### 内核模块加载与删除

除了上面使用到的modprobe命令,还可以使用insmod来安装模块.例如载入fat模块:

```sh
[root@101c7 ~]# insmod /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/fat.ko.xz 
[root@101c7 ~]# lsmod | grep fat
fat                    65950  0 
```

使用insmod命令必须接模块完整路径来安装,并且不会去分析模块的依赖性.

想要移除模块使用rmmod命令,例如移除fat模块:

```sh
[root@101c7 ~]# rmmod fat
[root@101c7 ~]# insmod /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/vfat.ko.xz 
insmod: ERROR: could not insert module /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/vfat.ko.xz: Unknown symbol in module
```

不过这样有个坏处就是需要手动处理依赖问题,比如上面fat模块被移除后,无法用insmod命令来载入vfat模块.

最稳妥的方式还是使用modprobe来处理.-f参数可以强制载入模块,-r参数用来移除模块:

```sh
[root@101c7 ~]# modprobe vfat
[root@101c7 ~]# lsmod | grep vfat
vfat                   17461  0 
fat                    65950  1 vfat
[root@101c7 ~]# modprobe -r vfat
```

如果想让模块开机自动载入,可以下面这样操作:

例如要加入启动一个nf_conntrack_frp模块,可以在目录下新建一个conf文件:

  ```sh
  [root@101c7 initrams]# vi /etc/modules-load.d/ftp.conf
  nf_conntrack_ftp
  "/etc/modules-load.d/ftp.conf" [New] 1L, 17C written
  ```

一个模块(驱动)写一行,上面模块是针对默认FTP端口设置,如果要调整到558端口,可以在modprobe.d目录下面新建配置:

  ```sh
  [root@101c7 initrams]# vi /etc/modprobe.d/ftp.conf
  options nf_conntrack_ftp ports=558
  "/etc/modprobe.d/ftp.conf" [New] 1L, 35C written
  ```

系统重启后就能顺利载入模块了.也可以通过重启systemd-modules-load服务来即刻生效:

  ```sh
  [root@101c7 initrams]# systemctl restart systemd-modules-load
  [root@101c7 initrams]# lsmod | grep nf_conntrack_ftp
  nf_conntrack_ftp       18478  0 
  nf_conntrack          139264  1 nf_conntrack_ftp
  ```



## 启动引导程序

目前在Linux下主要的引导启动程序是Grub或Grub2.通常Grub2主程序会将配置文件放到/boot/grub2目录下.Grub则是直接修改/boot/grub/grub.conf,一个很简单的配置文件.

grub2引导程序的特点有:

- 认识与支持更多文件系统,并且可以使用grub2的主程序直接在文件系统中搜寻内核文件名;

- 开机时候,可以自行编辑与修改开机设置项目,类似bash的命令模式;

- 可以动态搜寻配置文件,而不需要在修改配置后重新安装grub2.

grub2对硬盘的代号设置与Linux中不同,一般用下面代号:

- (hd0,1): 一般的默认语法,由grub2自动判断分区格式.

- (hd0,msdos1): 磁盘的分区为传统的MBR模式.

- (hd0,gpt1): 磁盘的分区为GPT模式.

硬盘代号用小括号()括起来,以搜寻顺序做硬盘编号,第一个分区从1开始计算,而不是grub的0开始算.

默认情况下grub2随系统已经装好了,特殊情况下要手动安装grub2可以使用grub2-install命令.例如安装到sdc下面:

```sh
[root@101c7 ~]# grub2-install /dev/sdc
Installing for i386-pc platform.
Installation finished. No error reported.
```

### Grub2配置文件

grub2的配置文件路径为:/boot/grub2/grub.cfg:

```sh
[root@101c7 ~]# cat /boot/grub2/grub.cfg
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by grub2-mkconfig using templates
# from /etc/grub.d and settings from /etc/default/grub
#

### BEGIN /etc/grub.d/00_header ###
set pager=1

if [ -s $prefix/grubenv ]; then
```

此文件内容众多,开头第一句就警告应该由grub2-mkconfig命令来创建配置,而不是直接修改它.

第一部分以### BEGIN /etc/grub.d/00_header ###开头下面的内容,大多与环境设置与默认值设置等.比较重要的是set default默认开机选项和set timeout默认超时时间.

第四部分以### BEGIN /etc/grub.d/10_linux ###开头段的内容设置了menuentry,也就是开机给的选择项.每个选项都有不同启动参数与模块载入.比较重要的有:

- set root: 设置grub2配置文件所在的分区hd0,msdos1,可以用mount查一下挂载的分区:

  ```sh
  [root@101c7 ~]# mount | grep boot
  /dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
  [root@101c7 ~]# fdisk -l
  Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
  Units = sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disk label type: dos
  ```

  结果显示/boot是挂载在sda1下面,并且分区为MBR格式.

- linux16 /vmlinuz: 指定内核文件,以及内核文件运行时加的参数.因为/boot独立分区的缘故,这里的内核文件路径是(hd0,msdos1)/vmlinuz.如果/boot挂载在根目录下面,内核路运行径会变成(hd0,msdos1)/boot/vmlinuz,也就是linux16 /boot/vmlinuz这样.后面的root指定的是Linux系统中根目录挂载的设备.

- initrd16 /initramfs: 指定虚拟文件系统img的位置.

### Grub2配置维护

我们可以通过修改/etc/default/grub文件和/etc/grub.d/目录内的相关配置文件来达成修改grub2配置的目的.

可以看一下/etc/default/grub文件内容:

```sh
[root@101c7 ~]# cat /etc/default/grub 
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_OUTPUT="console"
GRUB_CMDLINE_LINUX="crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet"
GRUB_DISABLE_RECOVERY="true"
```

重点选项代表的意义如下:

- GRUB_TIMEOUT: 设置在选择菜单等待超时秒数.设为0表示不等待,设为-1表示必须手动选择.

- GRUB_TIMEOUT_STYLE: 可以设置的值为menu,countdown,hidden等,默认为menu.这个参数也就是设置要不要显示菜单.设置为countdown或者hidden会让用户看不到任何内容.

- GRUB_DEFAULT: 菜单默认选择项目,可以设置的值有saved,数字,title名,ID名等,依据menuentry的设置而定.

  例如在配置中定义了三条menuentry:

  ```sh
  menuentry 'CentOS' --unrestricted $menuentry_id_option 'linux-1'
  menuentry 'Debian' --unrestricted $menuentry_id_option 'gnulinux'
  menuentry 'Windows' --unrestricted $menuentry_id_option 'win'
  ```

  那么对应GRUB_DEFAULT的值:

  - 值为1表示选用排在第2个定义的Debian系统,因为数字编号从0开始算.

  - 值为win表示选择排在第3个定义的Windows系统,通过id选的值.

  - 值为saved表示使用grub2-set-default来设置哪个为默认值,通常默认为0.

- GRUB_TERMINAL_OUTPUT: 信息输出的终端模式,可以设置值有console,serial,gfxterm,vga_text等.

- GRUB_CMDLINE_LINUX: 内核的外加参数功能,用来设置内核启动时还需要额外加入的参数.

例如修改菜单等待时间为30秒,之后用grub2-mkconfig来重建grub.cfg:

```sh
[root@101c7 ~]# sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=30/g' /etc/default/grub ; head -1 /etc/default/grub
GRUB_TIMEOUT=30
[root@101c7 ~]# grub2-mkconfig -o /boot/grub2/grub.cfg
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.10.0-1160.41.1.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img
Found linux image: /boot/vmlinuz-3.10.0-862.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-862.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-77a36143eb014dd5a0d6e738b1d84778
Found initrd image: /boot/initramfs-0-rescue-77a36143eb014dd5a0d6e738b1d84778.img
done
[root@101c7 ~]# grep timeout /boot/grub2/grub.cfg
if [ x$feature_timeout_style = xy ] ; then
  set timeout_style=menu
  set timeout=30
# Fallback normal timeout code in case the timeout_style feature is
  set timeout=30
```

再看一看/etc/grub.d文件夹的内容:

```sh
[root@101c7 ~]# ll /etc/grub.d
total 72
-rwxr-xr-x. 1 root root  8702 Mar 16  2021 00_header
-rwxr-xr-x. 1 root root  1043 Mar 21  2019 00_tuned
-rwxr-xr-x. 1 root root   232 Mar 16  2021 01_users
-rwxr-xr-x. 1 root root 10781 Mar 16  2021 10_linux
-rwxr-xr-x. 1 root root 10275 Mar 16  2021 20_linux_xen
-rwxr-xr-x. 1 root root  2559 Mar 16  2021 20_ppc_terminfo
-rwxr-xr-x. 1 root root 11169 Mar 16  2021 30_os-prober
-rwxr-xr-x. 1 root root   214 Mar 16  2021 40_custom
-rwxr-xr-x. 1 root root   216 Mar 16  2021 41_custom
-rw-r--r--. 1 root root   483 Mar 16  2021 README
```

可以看到文件名刚好和grub.cfg中段头对应.主要文件有:

- 00_header: 主要在创建初始的显示项目,包括需要载入的模块分析,屏幕终端格式,倒数秒数,菜单是否要隐藏等,大部分在/etc/default/grub里面设置的变量,用到这个脚本里用来重建grub.cfg.
- 01_users: 设置账号密码,用来管控每个菜单选项进入权限.权限用在menuentry中有三种:不受限(unrestricted),用户(users),超级用户(superusers).其中只有超级用户可以使用启动项编辑模式.

- 10_linux: 根据分析/boot下面的文件,尝试找到正确的Linux内核文件与虚拟文件系统镜像等,脚本会将找到的文件路径写入到grub.cfg中.因为每一内核文件都会建立一个启动选项,所以可以适当删除旧内核文件来精简启动菜单.

- 30_os-prober: 这个脚本用来找其他分区中可能存在的操作系统,如果找到则将其加入启动菜单中.可以在/etc/default/grub中加上`GRUB_DISABLE_OS_PROBER=true`参数来取消这一扫描.

- 40_custom: 用来手动添加菜单项目.例如想新增一个menuentry来指定开机进入图形模式,可以在grub.cfg中复制一个menuentry段,修改对应的title,id与linux16后面的参数(增加 systemd.unit=graphical.target),然后再用grub2-mkconfig命令重建grub.cfg即可.

### 设置多重引导

多重引导使用的叫开机管理程序的链接(Chain Loader)功能,将开机引导程序指向另外的地方.只需要设置另一个开机引导程序所在分区代号和所在扇区就行.

假设系统有一块硬盘两个分区,分别装了Linux(sdb1)和Windows(sdb2),那么我们需要增加两个开机选项,一个指向Windows开机菜单,一个回到MBR的默认环境,40_custom文件内容大致是这样:

```sh
[root@101c7 ~]# vi /etc/grub.d/40_custom 
#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.
menuentry 'Windows' --id 'win' {
        insmod chain
        insmod ntfs
        set root=(hd0,msdos2)
        chainloader +1
menuentry 'MBR' --id 'mbr' {
        insmod chain
        set root=(hd0)
        chainloader +1
"/etc/grub.d/40_custom" 14L, 469C written

```

其中最重要的是载入chain和ntfs模块,由此grub2才能正确读取文件系统执行Chain Loader功能.

### 启动项编辑模式

在启动菜单出现后,可以按e进入启动项编辑模式.也就是直接编辑grub.cfg文件内容.

例如可以在systemd.unit中指定为rescue.target,这样就能直接进入救援模式,而不需要先进入系统.修改完毕后用快捷键[Ctrl]+x来执行



## 启动异常处理

通常因为某些不正常的设置或不正常关机导致无法顺利开机时,可以进入rescue模式去处理.

### 忘记root密码

在使用grub做引导的系统可以这样处理:

1. 启动系统在选择启动项的界面下,按e进入默认启动项grub编辑模式.
2. 移动到有kernel那行,再按一次e进入编辑界面,在最后方输入`single`.
3. 按下回车,再按下b就可以进入单用户维护模式.
4. 这一模式下可以直接用`passwd`命令修改root密码.

CentOS 7中rescue模式也需要root密码才能登录,因此可以进入emergency救援模式:

1. 按e进入编辑默认启动项grub,找到linux16那行在最末尾输入`init=/bin/sh`,按[Ctrl]+x执行;
2. 进入emergency模式后,输入`mount -o remount,rw /`命令将根目录挂载为可读写模式;
3. 然后使用`passwd`命令设置新的root密码;
4. 最后输入`touch /.autorelabel`更新系统信息,让SELinux生效;
5. 执行`exec /sbin/init`或`reboot`即可退出救援模式.

通过rd.break(Ram Disk里面的操作系统)内核启动参数也可以处理:

1. 同样在编辑默认启动项grub,在linux16那行末尾加入`rd.break`参数,按[Ctrl]+x执行;
2. 此时进入的是Ram Disk环境,系统被挂载到/sysroot目录下,用`mount -o remount,rw /sysroot`重新挂载;
3. 用命令`chroot /sysroot`来切换根目录,并使用`passwd`命令修改密码;
4. 同样用`touch /.autorelabel`来变回SELinux的安全标签.重启即可.

touch /.autorelabel命令的作用:

- 在救援模式下系统没有SELinux,所以用passwd命令修改了/etc/shadow文件后,它的SELinux安全标签会被取消,在SELinux为Enforcing模式下会无法登录系统.

- 创建/.autorelabel文件就是要让系统在开机时自动使用默认SELinux类型重写入SELinux安全标签到每个文件.

- 如果不想让每个文件都更新标签,可以改完密码后,将SELinux运行模式改为permissive(修改/etc/selinux/config文件).再重新开机后运行`restorecon -Rv /etc`仅恢复/etc目录下的默认安全上下文类型.最后将SELinux配置文件的运行模式改回enforcing,用`setenforce 1`来生效.

### 文件系统错误

断电或不正常关机会导致文件系统错误,通常是软件数据问题,如果根目录没有损坏,可以进入维护模式下使用fsck命令修复ext4格式的分区,修复完毕后以reboot重启即可:

```sh
[root@101c7 ~]# fsck /dev/sda2
fsck from util-linux 2.23.2
```

如果是xfs格式分区则使用xfs_repair命令:

```sh
[root@101c7 ~]# xfs_repair /dev/sda2
xfs_repair: cannot open /dev/sda2: Device or resource busy
```

如果整个硬盘只有一个大区,那文件系统错误一定是根目录的问题.这时候需要将硬盘拔下来,接到另外一台Linux系统的机器上,并且不要挂载,以root身份执行fsck或xfs_repair命令修复.

还有一种方法是使用U盘刻成Live CD,在U盘启动的系统中执行修复命令.



## 关机重启

切换运行级别和模式并不会重启.

### 查看用户在线状态

如果有别的用户在线,强制关机可能会造成用户文件丢失,可以先使用*who*查看当前已登录的用户信息:

```shell
[user1@101c7 root]$ who -Hu
NAME     LINE         TIME             IDLE          PID COMMENT
root     tty1         2021-09-11 09:35  old          897
root     pts/0        2021-09-15 12:12   .          5334 (192.168.2.101)
root     pts/1        2021-09-14 08:40  old        55207 (192.168.2.101)
```

### 数据写回

默认情况下,某些依据加载内存中的数据将不会直接被写回硬盘,而是暂存在内存,可以手动同步将数据写入.

立即运行同步操作:

```shell
[user1@101c7 root]$ sync
```

使用重启关机命令前也会自动调用*sync*命令.

当非管理员使用*sync*命令时,只会更新操作用户的数据.

### 关机操作

通常使用*shutdown*命令来进行关机操作.

~~关机命令必须加入时间参数,否则会自动跳到run-level 1(单用户维护)模式~~

立马关机:

```shell
[user1@101c7 root]$ shutdown -h now
```

预定在21:00关机.如果当前时间超过21:00则会在隔天21:00才关机:

```shell
[user1@101c7 root]$ shutdown -h 21:00
```

预定2分钟后关机,并发送消息:

```shell
[root@101c7 ~]# shutdown -P 120 "will  poweroff"
Shutdown scheduled for Wed 2021-09-15 16:01:48 EDT, use 'shutdown -c' to cancel.
```

取消即将进行的关机操作:

```shell
[root@101c7 ~]# shutdown -c
[root@101c7 ~]# 
Broadcast message from root@101c7 (Wed 2021-09-15 14:01:54 EDT):

The system shutdown has been cancelled at Wed 2021-09-15 14:02:54 EDT!
```

### 重启操作

重启命令可用*reboot*或*halt*,选择其一即可.

立马强制关机:

```shell
[root@101c7 ~]# halt -P -f
```

同步后重启系统:

```shell
[root@101c7 ~]# sync; sync; sync; reboot
```

### 切换执行等级

可以通过init命令来切换运行等级,例如进入单用户维护模式:

```shell
[root@localhost ~]# init 1
Broadcast message from root@localhost.localdomain on pts/1 (Fri 2019-07-05 15:40:59 CST):

The system is going down to rescue mode NOW!
```

在CentOS7中则是由systemctl来管理模式之间的切换,例如切换到救援模式:

```sh
[root@101c7 ~]# systemctl isolate rescue.target
```



