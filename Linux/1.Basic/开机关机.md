# 开机关机

## 开机流程

目前主机系统在载入硬件驱动方面的程序,有使用BIOS与UEFI两种.

UEFI(Unified Extensible Firmware Interface)为新一代BIOS,可以使用一个特制的shell来做些管理工作.

### BIOS搭配MBR/GPT

简单来看,开机流程分为以下步骤:

1. 载入BIOS的硬件信息与自测,并根据设置取得第一个可开机的设备;
2. 读取并执行第一个可开机设备内MBR的引导加载程序(Boot Loader)(比如grub);
3. 依据引导加载程序设置,识别文件系统格式,加载核心文件.由内核开始检测硬件与驱动;
4. 硬件驱动成功后,Kernel会主动调用systemd程序,并以default.target流程开机:
   - 执行sysinit.target初始化系统及basic.target准备系统;
   - 启动multi-user.target下的本机与服务器服务;
   - 执行multi-user.target下的/etc/rc.d/rc.local文件;
   - 执行multi-user.target下的getty.target及登录服务;
   - 执行graphical需要的服务

GPT格式启动过程一样,差异在于开机管理程序是否支持GPT.

如果使用grub引导的话,得额外分个"BIOS boot"分区来放置其他开机过程所需得程序码.

### 多重引导

引导加载程序除了可以安装在MBR外,还可以安装到每个文件系统的引导扇区(Boot Sector).

例如硬盘第一和第二分区分别安装了Windows和Linux.开机装载第一个分区引导加载程序,此时会出现分支选项.可以选择启动Windows直接加载第一个分区中的Windows内核文件.选择启动Linux则转到第二个分区的引导扇区,由第二个分区的引导加载程序完成Linux系统启动工作.

如果要安装多重开机,一般先安装Windows再安装Linux,因为Windows安装时会直接覆盖掉MBR以及自己所在分区的引导扇区.而Linux安装时可以选择引导加载程序不安装到MBR,只装在指定分区的引导扇区.之后修改引导程序加入Windows开机选项,完成双系统引导功能.

### 硬件检测

在引导加载程序读取到内核文件后,Linux会将内核解压到内存中.利用内核开始测试与驱动硬件,包括CPU,硬盘,网卡等.此时Linux内核会以自己检测结果为准,也就是说内核此时开始接管BIOS后的工作了.

内核一般放置在/boot里面:

```sh
[root@101c7 ~]# ll /boot
total 149232
-rw-r--r--. 1 root root   153596 Aug 31 10:57 config-3.10.0-1160.41.1.el7.x86_64
-rw-r--r--. 1 root root   147819 Apr 20  2018 config-3.10.0-862.el7.x86_64
drwxr-xr-x. 3 root root       17 Sep  7 13:34 efi
drwxr-xr-x. 2 root root       27 Sep  7 13:35 grub
drwx------. 5 root root      132 Sep  7 05:55 grub2
-rw-------. 1 root root 55385253 Sep  7 13:37 initramfs-0-rescue-77a36143eb014dd5a0d6e738b1d84778.img
-rw-------. 1 root root 21322754 Sep  7 05:55 initramfs-3.10.0-1160.41.1.el7.x86_64.img
-rw-------. 1 root root 13851614 Sep 18 23:13 initramfs-3.10.0-1160.41.1.el7.x86_64kdump.img
-rw-------. 1 root root 21288233 Sep  7 05:56 initramfs-3.10.0-862.el7.x86_64.img
-rw-------. 1 root root 13761710 Sep  9 15:00 initramfs-3.10.0-862.el7.x86_64kdump.img
-rw-r--r--. 1 root root   320757 Aug 31 10:57 symvers-3.10.0-1160.41.1.el7.x86_64.gz
-rw-r--r--. 1 root root   304926 Apr 20  2018 symvers-3.10.0-862.el7.x86_64.gz
-rw-------. 1 root root  3620596 Aug 31 10:57 System.map-3.10.0-1160.41.1.el7.x86_64
-rw-------. 1 root root  3409143 Apr 20  2018 System.map-3.10.0-862.el7.x86_64
-rwxr-xr-x. 1 root root  6224704 Sep  7 13:37 vmlinuz-0-rescue-77a36143eb014dd5a0d6e738b1d84778
-rwxr-xr-x. 1 root root  6773352 Aug 31 10:57 vmlinuz-3.10.0-1160.41.1.el7.x86_64
-rwxr-xr-x. 1 root root  6224704 Apr 20  2018 vmlinuz-3.10.0-862.el7.x86_64
```

文件说明如下所示:

| 文件                 | 说明                                       |
| -------------------- | ------------------------------------------ |
| config-*             | 此版本内核被编译时选择的功能与模块配置文件 |
| grub,grub2           | 开机管理程序grub相关数据目录               |
| initramfs-0-rescue-* | 救援模式的虚拟文件系统                     |
| initramfs-*.img      | 正常模式的虚拟文件系统                     |
| initramfs-*kdump.img | 内核出问题时用到的虚拟文件系统             |
| System.map-*         | 内核功能放置到内存位址的对应表             |
| vmlinuz-0-rescue-*   | 救援模式的内核文件                         |
| vmlinuz-*            | 正常模式的内核文件                         |

### 虚拟文件系统

Linux内核可以动态载入核心模块(驱动),这些核心模块放置在/lib/modules/目录内.由于模块放置到根目录内,因此开机过程中内核必须要以只读方式挂载根目录,才可以读取到驱动程序.

但是在挂载根目录时,很大可能Linux内核并不认识SATA设备.为了让内核顺利执行下去,引用了一个虚拟文件系统(Initial RAM Disk或Initial RAM Filesystem)来处理,就是在/boot目录内用initramfs命名的img文件.

虚拟文件系统的img文件也能被boot loader载入到内存中,解压后在内存中仿真成一个根目录.再由此虚拟文件系统提供一个专用程序,来载入开机过程中所需要的驱动,通常是与磁盘接口的驱动程序.等驱动载入完毕,此虚拟文件系统被卸载,并挂载实际的根目录文件系统,继续开始后续开机流程.

可以用lsinitrd命令查看initramfs镜像的内容:

```sh
[root@101c7 ~]# lsinitrd /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img 
Image: /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img: 21M
========================================================================
Early CPIO image
========================================================================
drwxr-xr-x   3 root     root            0 Sep  7 05:55 .
-rw-r--r--   1 root     root            2 Sep  7 05:55 early_cpio
drwxr-xr-x   3 root     root            0 Sep  7 05:55 kernel
drwxr-xr-x   3 root     root            0 Sep  7 05:55 kernel/x86
drwxr-xr-x   2 root     root            0 Sep  7 05:55 kernel/x86/microcode
-rw-r--r--   1 root     root         6476 Sep  7 05:55 kernel/x86/microcode/AuthenticAMD.bin
========================================================================
Version: dracut-033-572.el7

Arguments: -f

dracut modules:
bash
nss-softokn
i18n
microcode_ctl-fw_dir_override
shutdown
========================================================================
drwxr-xr-x  12 root     root            0 Sep  7 05:55 .
crw-r--r--   1 root     root       5,   1 Sep  7 05:55 dev/console
crw-r--r--   1 root     root       1,  11 Sep  7 05:55 dev/kmsg
crw-r--r--   1 root     root       1,   3 Sep  7 05:55 dev/null
lrwxrwxrwx   1 root     root            7 Sep  7 05:55 bin -> usr/bin
drwxr-xr-x   2 root     root            0 Sep  7 05:55 dev
```

可以看到这个img文件里头分为两部分:前面部分是事先宣告的一些数据,包括一个可执行bin文件,后面部分才是内核会去读取的重要文件.

进一步将整个img解压:

```sh
[root@101c7 initrams]# cp /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img init.img
[root@101c7 initrams]# file init.img 
init.img: ASCII cpio archive (SVR4 with no CRC)
[root@101c7 initrams]# /usr/lib/dracut/skipcpio init.img | zcat | cpio -div
init
shutdown
88189 blocks
[root@101c7 initrams]# ll
total 8
lrwxrwxrwx.  1 root root    7 Sep 19 09:10 bin -> usr/bin
drwxr-xr-x.  2 root root   45 Sep 19 09:10 dev
drwxr-xr-x. 12 root root 4096 Sep 19 09:10 etc
lrwxrwxrwx.  1 root root   23 Sep 19 09:10 init -> usr/lib/systemd/systemd
lrwxrwxrwx.  1 root root    7 Sep 19 09:10 lib -> usr/lib
lrwxrwxrwx.  1 root root    9 Sep 19 09:10 lib64 -> usr/lib64
drwxr-xr-x.  2 root root    6 Sep 19 09:10 proc
drwxr-xr-x.  2 root root    6 Sep 19 09:10 root
drwxr-xr-x.  2 root root    6 Sep 19 09:10 run
lrwxrwxrwx.  1 root root    8 Sep 19 09:10 sbin -> usr/sbin
-rwxr-xr-x.  1 root root 3117 Sep 19 09:10 shutdown
drwxr-xr-x.  2 root root    6 Sep 19 09:10 sys
drwxr-xr-x.  2 root root    6 Sep 19 09:10 sysroot
drwxr-xr-x.  2 root root    6 Sep 19 09:10 tmp
drwxr-xr-x.  7 root root   66 Sep 19 09:10 usr
drwxr-xr-x.  2 root root   29 Sep 19 09:10 var
```

解压以后查询一下这个文件系统中systemd调用的运行模式:

```sh
[root@101c7 initrams]# ll usr/lib/systemd/system/default.target
lrwxrwxrwx. 1 root root 13 Sep 19 09:10 usr/lib/systemd/system/default.target -> initrd.target
[root@101c7 initrams]# systemctl list-dependencies initrd.target
initrd.target
● ├─dracut-cmdline.service
● ├─dracut-initqueue.service
● ├─dracut-mount.service
● ├─dracut-pre-mount.service
```

通过查询initrd.target可以知道内核先是用载入小型文件系统中的basic.target,sysinit.target等功能启用的流程,让系统顺利运行,再卸载虚拟文件系统,挂载实际系统根目录:

```sh
[root@101c7 initrams]# ll usr/lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/ata/ |grep "^-"|wc -l
4
[root@101c7 initrams]# ll /usr/lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/ata/ |grep "^-"|wc -l
49
```

不过对比一下会发现这个虚拟系统带的驱动大多是和硬盘有关.

### systemd流程

在内核载入完毕硬件驱动完后,内核会主动调用第一个程序systemd来启动basic.target

接下来到/usr/lib/systemd/system/目录下去调用multi-user.target(default.target)

再然后系统会到/etc/systemd/system/multi-user.target.wants/目录去找用户设置开机启动服务(unit).

到/usr/lib/systemd/system/multi-user.target.wants/目录去找系统默认的开机启动服务(unit).

至于最终启动的的服务有哪些,可以用systemctl list-dependencies来查询:

```sh
[root@101c7 initrams]# systemctl list-dependencies multi-user.target | grep target
multi-user.target
● ├─basic.target
● │ ├─selinux-policy-migrate-local-changes@targeted.service
● │ ├─paths.target
● │ ├─slices.target
● │ ├─sockets.target
● │ ├─sysinit.target
● │ │ ├─cryptsetup.target
● │ │ ├─local-fs.target
● │ │ └─swap.target
● │ └─timers.target
● ├─getty.target
● └─remote-fs.target
```

另外为兼容旧有通过/etc/rc.d/rc.local配置启动脚本,CentOs 7留有一个rc-local.service来执行它们.



















## 关机重启

切换运行级别和模式并不会重启.

### 查看用户在线状态

如果有别的用户在线,强制关机可能会造成用户文件丢失,可以先使用*who*查看当前已登录的用户信息:

```shell
[user1@101c7 root]$ who -Hu
NAME     LINE         TIME             IDLE          PID COMMENT
root     tty1         2021-09-11 09:35  old          897
root     pts/0        2021-09-15 12:12   .          5334 (192.168.2.101)
root     pts/1        2021-09-14 08:40  old        55207 (192.168.2.101)
```

### 数据写回

默认情况下,某些依据加载内存中的数据将不会直接被写回硬盘,而是暂存在内存,可以手动同步将数据写入.

立即运行同步操作:

```shell
[user1@101c7 root]$ sync
```

使用重启关机命令前也会自动调用*sync*命令.

当非管理员使用*sync*命令时,只会更新操作用户的数据.

### 关机操作

通常使用*shutdown*命令来进行关机操作.

~~关机命令必须加入时间参数,否则会自动跳到run-level 1(单用户维护)的登录情况~~

立马关机:

```shell
[user1@101c7 root]$ shutdown -h now
```

预定在21:00关机.如果当前时间超过21:00则会在隔天21:00才关机:

```shell
[user1@101c7 root]$ shutdown -h 21:00
```

预定2分钟后关机,并发送消息:

```shell
[root@101c7 ~]# shutdown -P 120 "will  poweroff"
Shutdown scheduled for Wed 2021-09-15 16:01:48 EDT, use 'shutdown -c' to cancel.
```

取消即将进行的关机操作:

```shell
[root@101c7 ~]# shutdown -c
[root@101c7 ~]# 
Broadcast message from root@101c7 (Wed 2021-09-15 14:01:54 EDT):

The system shutdown has been cancelled at Wed 2021-09-15 14:02:54 EDT!
```

### 重启操作

重启命令可用*reboot*或*halt*,选择其一即可.

立马强制关机:

```shell
[root@101c7 ~]# halt -P -f
```

同步后重启系统:

```shell
[root@101c7 ~]# sync; sync; sync; reboot
```

### 切换执行等级

可以通过i*nit*命令来切换运行等级,例如进入单用户维护模式:

```shell
[root@localhost ~]# init 1
Broadcast message from root@localhost.localdomain on pts/1 (Fri 2019-07-05 15:40:59 CST):

The system is going down to rescue mode NOW!
```

在CentOS7中则是由systemctl来管理模式之间的切换,例如切换到救援模式:

```sh
[root@101c7 ~]# systemctl isolate rescue.target
```



