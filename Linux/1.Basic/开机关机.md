# 开机关机

## 开机流程

目前主机系统在载入硬件驱动方面的程序,有使用BIOS与UEFI两种.

UEFI(Unified Extensible Firmware Interface)为新一代BIOS,可以使用一个特制的shell来做些管理工作.

### BIOS搭配MBR/GPT

简单来看,开机流程分为以下步骤:

1. 载入BIOS的硬件信息与自测,并根据设置取得第一个可开机的设备;
2. 通过硬件的INT 13中断功能,读取并执行第一个可开机设备内MBR的引导加载程序(Boot Loader);
3. 依据引导加载程序设置,识别文件系统格式,加载核心文件.由内核开始检测硬件与驱动;
4. 1 硬件驱动成功后,Kernel会主动调用systemd程序,并以default.target流程开机:
   - 执行sysinit.target初始化系统及basic.target准备系统;
   - 启动multi-user.target下的本机与服务器服务;
   - 执行multi-user.target下的/etc/rc.d/rc.local文件;
   - 执行multi-user.target下的getty.target及登录服务;
   - 执行graphical需要的服务.

4. 2 如果是早前版本,Kernel调用的init进程,init会取得run level信息:
   - init执行/etc/rc.d/rc.sysint文件来准备软件执行的操作环境(网络,市区等);
   - init执行run level的各个服务的启动(脚本方式);
   - init执行/etc/rc.d/rc.local文件;
   - init执行终端模拟程序mingetty来启动login进程.

GPT格式启动过程一样,差异在于开机管理程序是否支持GPT.

如果使用grub引导的话,得额外分个Boot分区来放置其他开机过程所需得程序码.

### 多重引导

引导加载程序除了可以安装在MBR外,还可以安装到每个文件系统的引导扇区(Boot Sector).

例如硬盘第一和第二分区分别安装了Windows和Linux.开机装载第一个分区引导加载程序,此时会出现分支选项.可以选择启动Windows直接加载第一个分区中的Windows核心文件.选择启动Linux则转到第二个分区的引导扇区,由第二个分区的引导加载程序完成Linux系统启动工作.

如果要安装多重开机,一般先安装Windows再安装Linux,因为Windows安装时会直接覆盖掉MBR以及自己所在分区的引导扇区,并且Windows的引导程序默认没有转移引导功能.而Linux安装时可以选择引导加载程序不安装到MBR,只装在指定分区的引导扇区.之后修改引导程序加入Windows开机选项,完成双系统引导功能.

### 硬件检测

在引导加载程序读取到内核文件后,Linux会将内核解压到内存中.利用内核开始测试与驱动硬件,包括CPU,硬盘,网卡等.此时Linux内核会以自己检测结果为准,也就是说内核此时开始接管BIOS后的工作了.

内核一般放置在/boot里面:

```sh
[root@101c7 ~]# ll /boot
total 149232
-rw-r--r--. 1 root root   153596 Aug 31 10:57 config-3.10.0-1160.41.1.el7.x86_64
-rw-r--r--. 1 root root   147819 Apr 20  2018 config-3.10.0-862.el7.x86_64
drwxr-xr-x. 3 root root       17 Sep  7 13:34 efi
drwxr-xr-x. 2 root root       27 Sep  7 13:35 grub
drwx------. 5 root root      132 Sep  7 05:55 grub2
-rw-------. 1 root root 55385253 Sep  7 13:37 initramfs-0-rescue-77a36143eb014dd5a0d6e738b1d84778.img
-rw-------. 1 root root 21322754 Sep  7 05:55 initramfs-3.10.0-1160.41.1.el7.x86_64.img
-rw-------. 1 root root 13851614 Sep 18 23:13 initramfs-3.10.0-1160.41.1.el7.x86_64kdump.img
-rw-------. 1 root root 21288233 Sep  7 05:56 initramfs-3.10.0-862.el7.x86_64.img
-rw-------. 1 root root 13761710 Sep  9 15:00 initramfs-3.10.0-862.el7.x86_64kdump.img
-rw-r--r--. 1 root root   320757 Aug 31 10:57 symvers-3.10.0-1160.41.1.el7.x86_64.gz
-rw-r--r--. 1 root root   304926 Apr 20  2018 symvers-3.10.0-862.el7.x86_64.gz
-rw-------. 1 root root  3620596 Aug 31 10:57 System.map-3.10.0-1160.41.1.el7.x86_64
-rw-------. 1 root root  3409143 Apr 20  2018 System.map-3.10.0-862.el7.x86_64
-rwxr-xr-x. 1 root root  6224704 Sep  7 13:37 vmlinuz-0-rescue-77a36143eb014dd5a0d6e738b1d84778
-rwxr-xr-x. 1 root root  6773352 Aug 31 10:57 vmlinuz-3.10.0-1160.41.1.el7.x86_64
-rwxr-xr-x. 1 root root  6224704 Apr 20  2018 vmlinuz-3.10.0-862.el7.x86_64
```

文件说明如下所示:

| 文件                 | 说明                                       |
| -------------------- | ------------------------------------------ |
| config-*             | 此版本内核被编译时选择的功能与模块配置文件 |
| grub,grub2           | 开机管理程序grub相关数据目录               |
| initramfs-0-rescue-* | 救援模式的虚拟文件系统                     |
| initramfs-*.img      | 正常模式的虚拟文件系统                     |
| initramfs-*kdump.img | 内核出问题时用到的虚拟文件系统             |
| System.map-*         | 内核功能放置到内存位址的对应表             |
| vmlinuz-0-rescue-*   | 救援模式的内核文件                         |
| vmlinuz-*            | 正常模式的内核文件                         |

### 虚拟文件系统

Linux内核可以动态载入核心模块(驱动),这些核心模块放置在/lib/modules/目录内.由于模块放置到根目录内,因此开机过程中内核必须要以只读方式挂载根目录,才可以读取到驱动程序.

但是在挂载根目录时,很大可能Linux内核并不认识SATA设备.为了让内核顺利执行下去,引用了一个虚拟文件系统(Initial RAM Disk或Initial RAM Filesystem)来处理,就是在/boot目录内用initramfs命名的img文件.

虚拟文件系统的img文件也能被引导加载程序载入到内存中,解压后在内存中仿真成一个根目录.内核会读取虚拟文件系统内的驱动,通常是与磁盘接口有关的驱动程序.等驱动载入完毕,此虚拟文件系统被卸载,并挂载实际的根目录文件系统,继续开始后续开机流程.

虚拟文件系统除了提供硬盘驱动外,还用于提供其他必须要在内核载入时用的模块,处理根目录的特殊文件系统格式.

可以用lsinitrd命令查看initramfs镜像的内容:

```sh
[root@101c7 ~]# lsinitrd /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img 
Image: /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img: 21M
========================================================================
Early CPIO image
========================================================================
drwxr-xr-x   3 root     root            0 Sep  7 05:55 .
-rw-r--r--   1 root     root            2 Sep  7 05:55 early_cpio
drwxr-xr-x   3 root     root            0 Sep  7 05:55 kernel
drwxr-xr-x   3 root     root            0 Sep  7 05:55 kernel/x86
drwxr-xr-x   2 root     root            0 Sep  7 05:55 kernel/x86/microcode
-rw-r--r--   1 root     root         6476 Sep  7 05:55 kernel/x86/microcode/AuthenticAMD.bin
========================================================================
Version: dracut-033-572.el7

Arguments: -f

dracut modules:
bash
nss-softokn
i18n
microcode_ctl-fw_dir_override
shutdown
========================================================================
drwxr-xr-x  12 root     root            0 Sep  7 05:55 .
crw-r--r--   1 root     root       5,   1 Sep  7 05:55 dev/console
crw-r--r--   1 root     root       1,  11 Sep  7 05:55 dev/kmsg
crw-r--r--   1 root     root       1,   3 Sep  7 05:55 dev/null
lrwxrwxrwx   1 root     root            7 Sep  7 05:55 bin -> usr/bin
drwxr-xr-x   2 root     root            0 Sep  7 05:55 dev
```

可以看到这个img文件里头分为两部分:前面部分是事先宣告的一些数据,包括一个可执行bin文件,后面部分才是内核会去读取的重要文件.

进一步将整个img解压:

```sh
[root@101c7 initrams]# cp /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img init.img
[root@101c7 initrams]# file init.img 
init.img: ASCII cpio archive (SVR4 with no CRC)
[root@101c7 initrams]# /usr/lib/dracut/skipcpio init.img | zcat | cpio -div
init
shutdown
88189 blocks
[root@101c7 initrams]# ll
total 8
lrwxrwxrwx.  1 root root    7 Sep 19 09:10 bin -> usr/bin
drwxr-xr-x.  2 root root   45 Sep 19 09:10 dev
drwxr-xr-x. 12 root root 4096 Sep 19 09:10 etc
lrwxrwxrwx.  1 root root   23 Sep 19 09:10 init -> usr/lib/systemd/systemd
lrwxrwxrwx.  1 root root    7 Sep 19 09:10 lib -> usr/lib
lrwxrwxrwx.  1 root root    9 Sep 19 09:10 lib64 -> usr/lib64
drwxr-xr-x.  2 root root    6 Sep 19 09:10 proc
drwxr-xr-x.  2 root root    6 Sep 19 09:10 root
drwxr-xr-x.  2 root root    6 Sep 19 09:10 run
lrwxrwxrwx.  1 root root    8 Sep 19 09:10 sbin -> usr/sbin
-rwxr-xr-x.  1 root root 3117 Sep 19 09:10 shutdown
drwxr-xr-x.  2 root root    6 Sep 19 09:10 sys
drwxr-xr-x.  2 root root    6 Sep 19 09:10 sysroot
drwxr-xr-x.  2 root root    6 Sep 19 09:10 tmp
drwxr-xr-x.  7 root root   66 Sep 19 09:10 usr
drwxr-xr-x.  2 root root   29 Sep 19 09:10 var
```

解压以后查询一下这个文件系统中systemd调用的运行模式:

```sh
[root@101c7 initrams]# ll usr/lib/systemd/system/default.target
lrwxrwxrwx. 1 root root 13 Sep 19 09:10 usr/lib/systemd/system/default.target -> initrd.target
[root@101c7 initrams]# systemctl list-dependencies initrd.target
initrd.target
● ├─dracut-cmdline.service
● ├─dracut-initqueue.service
● ├─dracut-mount.service
● ├─dracut-pre-mount.service
```

通过查询initrd.target可以知道内核先是用载入小型文件系统中的basic.target,sysinit.target等功能启用的流程,让系统顺利运行,再卸载虚拟文件系统,挂载实际系统根目录:

```sh
[root@101c7 initrams]# ll usr/lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/ata/ |grep "^-"|wc -l
4
[root@101c7 initrams]# ll /usr/lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/ata/ |grep "^-"|wc -l
49
```

不过对比一下会发现这个虚拟系统带的驱动大多是和硬盘有关.

要想创建一个自定义的initramfs镜像,可以使用dracut或mkinitrd来处理.例如新建一个添加了x200网卡驱动与nfs文件系统驱动的initramfs镜像:

```sh
[root@101c7 ~]# dracut -v -add-drivers "x200" --filesystems "nfs" > initramfs-new.img & (uname -r)
```

### systemd流程

在内核载入完毕硬件驱动完后,内核会主动调用第一个程序systemd来启动basic.target

接下来到/usr/lib/systemd/system/目录下去调用multi-user.target(default.target)

再然后系统会到/etc/systemd/system/multi-user.target.wants/目录去找用户设置开机启动服务(unit).

到/usr/lib/systemd/system/multi-user.target.wants/目录去找系统默认的开机启动服务(unit).

至于最终启动的的服务有哪些,可以用systemctl list-dependencies来查询:

```sh
[root@101c7 initrams]# systemctl list-dependencies multi-user.target | grep target
multi-user.target
● ├─basic.target
● │ ├─selinux-policy-migrate-local-changes@targeted.service
● │ ├─paths.target
● │ ├─slices.target
● │ ├─sockets.target
● │ ├─sysinit.target
● │ │ ├─cryptsetup.target
● │ │ ├─local-fs.target
● │ │ └─swap.target
● │ └─timers.target
● ├─getty.target
● └─remote-fs.target
```

另外为兼容旧有通过/etc/rc.d/rc.local配置启动脚本,CentOs 7留有一个rc-local.service来执行它们.

开机会读取的文件目录如下:

- /etc/modules-load.d/*.conf: 

  单纯要核心载入模块的位置

- /etc/modprobe.d/*.conf: 

  可以加上模块参数的位置

- /etc/sysconfig:

  系统配置目录下面由非常多的环境配置文件,重要的有:

  - authconfig: 用于规范使用者的身份认证机制,包括是否使用本机/etc/passwd,/etc/shadow等,以及密码记录使用的加密算法,是否用外部密码服务器提供的账号验证(NIS,LDAP)等.

  - cpupower: 如果启动了cpupower.service服务时,会读取这个配置文件.

  - firewalld,iptables-config,iptables-config,ebtables-config: 与防火墙服务有关配置.

  - network-scripts: 网卡的设置.

### init流程

在内核加载完硬件驱动后,内核会主动去调用第一个进程/sbin/init.它最主要的功能是准备软件执行环境.

init通过配置文件/etc/inittab规划行动.配置文件每行内容由:分隔四个字段:

- 设置选项: 最多四个字符,代表init的主要工作选项,只是一个说明.

- 执行等级: 代表该选项在哪些执行等级下面运行,如果是35表示在执行等级3/5都会执行.

- init的操作行为: 可以设置的值有

  - initdefault: 默认执行等级设置值

  - sysinit: 系统初始化的操作选项

  - ctrlaltdel: 代表组合快捷键[Ctrl]+[Alt]+[Del]是否可以重新启动的设置

  - wait: 代表后面设置的命令必须要执行完毕才能继续下面其他操作

  - respawn: 代表后面的命令可以无限重启,例如tty1

- 命令选项: 执行的命令,通常是一些脚本

init首先是取得默认执行等级,然后使用/etc/rc.d/rc.sysinit来初始化.

如果执行等级是5,则只进行5:5:wait:/etc/rc.d/rc5这行:

- 对应和rc5相关的脚本存放在/etc/rc5.d/下面,以Kxx开头的文件代表执行stop,以Sxx开头代表执行start操作.
- 这些脚本全部是连接文件,连接到stand alone服务启动的目录/etc/init.d/内.
- S或K后面两位数字代表执行顺序,数字越小执行越早.

设置好组合键功能和不断电系统pf,pr机制.

启动用户自定义脚本/etc/rc.d/rc.local配置文件内的程序.

启动mingetty的6个终端机,最后以/etc/X11/perfdm -nodaemon启动图形界面.

开机用到的配置文件:

- /etc/modprobe.conf

  定义开机要加载的模块,模块存放于/etc/sysconfig/modules/目录下

- /etc/sysconfig/*

  服务相关配置,重要的有:

  - authconfig: 设置用户身份认证机制
  - clock: 设置Linux主机的时区
  - i18n: 设置语系
  - keyboard & mouse: 设置键盘与鼠标样式
  - network: 设置是否要启动网络,主机名和网关
  - network-scripts: 设置网卡


## 内核模块管理

内核与内核模块在下面路径:

- 内核: /boot/vmlinuz

- 虚拟文件系统(RAM Disk): /boot/initramfs

- 内核模块: /lib/modules/version/kernel

- 内核源代码: /usr/src/linux

如果有操作系统不支持的新硬件要安装,可以重新编译内核,将硬件驱动加入进去.或者把硬件驱动编译成模块,在开机时载入.

### 内核模块依赖

在内核模块目录中通常分为以下几个子目录:

- arch: 与硬件平台有关的项目,如CPU的等级
- crypto: 内核所支持的加密技术,例如md5,des等
- drivers: 一些硬件的驱动程序,如网卡,显卡驱动等
- fs: 内核支持的文件系统,如vfat,nfs等
- lib: 一些函数库
- net: 与网络有关的各项协定数据,包括防火墙
- sound: 与声音有关模块

内核模块之间的依赖性检查通过/lib/modules/version/modules.dep来记录,可以使用depmod命令来加入已编译好的模块.例如要加入名为tp-413.ko网卡驱动到内核模块:

```sh
[root@101c7 ~]# cp tp-413.ko /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/drivers/net/
[root@101c7 ~]# depmod
```

执行depod命令后,程序会跑到内核模块目录,将全部模块分析一遍,将结果写入到modules.dep文件中.

### 内核模块查询

要查询内核以及加载的模块列表,可以使用lsmod命令:

```sh
[root@101c7 ~]# lsmod
Module                  Size  Used by
nf_conntrack_ftp       18478  0 
nf_conntrack          139264  1 nf_conntrack_ftp
snd_seq_midi           13565  0 
snd_seq_midi_event     14597  1 snd_seq_midi
```

结果会分别显示出模块名称,模块大小和模块被其他模块使用(Used by)的信息.

如果想要查询模块具体信息,可以使用modinfo命令.例如查询nf_conntrack_ftp模块:

```sh
[root@101c7 ~]# modinfo nf_conntrack_ftp
filename:       /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/net/netfilter/nf_conntrack_ftp.ko.xz
alias:          nfct-helper-ftp
alias:          ip_conntrack_ftp
description:    ftp connection tracking helper
author:         Rusty Russell <rusty@rustcorp.com.au>
license:        GPL
retpoline:      Y
rhelversion:    7.9
srcversion:     F21861D5AD43080B93CC4DD
depends:        nf_conntrack
intree:         Y
vermagic:       3.10.0-1160.41.1.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        4B:E3:B8:E9:52:F4:81:B2:62:51:AC:E4:66:9B:A7:99:71:D1:F1:AF
sig_hashalgo:   sha256
parm:           ports:array of ushort
parm:           loose:bool
```

从上面查询可以得到模块的文件位置,依赖的模块,还有模块的参数(parm).

### 内核模块加载与删除

除了上面使用到的modprobe命令,还可以使用insmod来安装模块.例如载入fat模块:

```sh
[root@101c7 ~]# insmod /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/fat.ko.xz 
[root@101c7 ~]# lsmod | grep fat
fat                    65950  0 
```

使用insmod命令必须接模块完整路径来安装,并且不会去分析模块的依赖性.

想要移除模块使用rmmod命令,例如移除fat模块:

```sh
[root@101c7 ~]# rmmod fat
[root@101c7 ~]# insmod /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/vfat.ko.xz 
insmod: ERROR: could not insert module /lib/modules/3.10.0-1160.41.1.el7.x86_64/kernel/fs/fat/vfat.ko.xz: Unknown symbol in module
```

不过这样有个坏处就是需要手动处理依赖问题,比如上面fat模块被移除后,无法用insmod命令来载入vfat模块.

最稳妥的方式还是使用modprobe来处理.-f参数可以强制载入模块,-r参数用来移除模块:

```sh
[root@101c7 ~]# modprobe vfat
[root@101c7 ~]# lsmod | grep vfat
vfat                   17461  0 
fat                    65950  1 vfat
[root@101c7 ~]# modprobe -r vfat
```

如果想让模块开机自动载入,可以下面这样操作:

例如要加入启动一个nf_conntrack_frp模块,可以在目录下新建一个conf文件:

  ```sh
  [root@101c7 initrams]# vi /etc/modules-load.d/ftp.conf
  nf_conntrack_ftp
  "/etc/modules-load.d/ftp.conf" [New] 1L, 17C written
  ```

一个模块(驱动)写一行,上面模块是针对默认FTP端口设置,如果要调整到558端口,可以在modprobe.d目录下面新建配置:

  ```sh
  [root@101c7 initrams]# vi /etc/modprobe.d/ftp.conf
  options nf_conntrack_ftp ports=558
  "/etc/modprobe.d/ftp.conf" [New] 1L, 35C written
  ```

系统重启后就能顺利载入模块了.也可以通过重启systemd-modules-load服务来即刻生效:

  ```sh
  [root@101c7 initrams]# systemctl restart systemd-modules-load
  [root@101c7 initrams]# lsmod | grep nf_conntrack_ftp
  nf_conntrack_ftp       18478  0 
  nf_conntrack          139264  1 nf_conntrack_ftp
  ```



## 启动引导程序

目前在Linux下主要的引导启动程序是Grub或Grub2.通常Grub2主程序会将配置文件放到/boot/grub2目录下.

grub2引导程序的特点有:

- 认识与支持更多文件系统,并且可以使用grub2的主程序直接在文件系统中搜寻核心文件名;

- 开机时候,可以自行编辑与修改开机设置项目,类似bash的命令模式;

- 可以动态搜寻配置文件,而不需要在修改配置后重新安装grub2.

grub2对硬盘的代号设置与Linux中不同,一般用下面代号:

- (hd0,1): 一般的默认语法,由grub2自动判断分区格式.

- (hd0,msdos1): 磁盘的分区为传统的MBR模式.

- (hd0,gpt1): 磁盘的分区为GPT模式.

硬盘代号用小括号()括起来,以搜寻顺序做硬盘编号,第一个分区从1开始计算,而不是grub的0开始算.

默认情况下grub2随系统已经装好了,特殊情况下要手动安装grub2可以使用grub2-install命令.例如安装到sdc下面:

```sh
[root@101c7 ~]# grub2-install /dev/sdc
Installing for i386-pc platform.
Installation finished. No error reported.
```

### Grub2配置文件

grub2的配置文件路径为:/boot/grub2/grub.cfg:

```sh
[root@101c7 ~]# cat /boot/grub2/grub.cfg
#
# DO NOT EDIT THIS FILE
#
# It is automatically generated by grub2-mkconfig using templates
# from /etc/grub.d and settings from /etc/default/grub
#

### BEGIN /etc/grub.d/00_header ###
set pager=1

if [ -s $prefix/grubenv ]; then
```

此文件内容众多,开头第一句就警告应该由grub2-mkconfig命令来创建配置,而不是直接修改它.

第一部分以### BEGIN /etc/grub.d/00_header ###开头下面的内容,大多与环境设置与默认值设置等.比较重要的是set default默认开机选项和set timeout默认超时时间.

第四部分以### BEGIN /etc/grub.d/10_linux ###开头段的内容设置了menuentry,也就是开机给的选择项.每个选项都有不同启动参数与模块载入.比较重要的有:

- set root: 设置grub2配置文件所在的分区hd0,msdos1,可以用mount查一下挂载的分区:

  ```sh
  [root@101c7 ~]# mount | grep boot
  /dev/sda1 on /boot type xfs (rw,relatime,seclabel,attr2,inode64,noquota)
  [root@101c7 ~]# fdisk -l
  Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
  Units = sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disk label type: dos
  ```

  结果显示/boot是挂载在sda1下面,并且分区为MBR格式.

- linux16 /vmlinuz: 指定内核文件,以及内核文件运行时加的参数.因为/boot独立分区的缘故,这里的内核文件路径是(hd0,msdos1)/vmlinuz.如果/boot挂载在根目录下面,内核路运行径会变成(hd0,msdos1)/boot/vmlinuz,也就是linux16 /boot/vmlinuz这样.后面的root指定的是Linux系统中根目录挂载的设备.

- initrd16 /initramfs: 指定虚拟文件系统img的位置.

### Grub2配置维护

我们可以通过修改/etc/default/grub文件和/etc/grub.d/目录内的相关配置文件来达成修改grub2配置的目的.

可以看一下/etc/default/grub文件内容:

```sh
[root@101c7 ~]# cat /etc/default/grub 
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_OUTPUT="console"
GRUB_CMDLINE_LINUX="crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet"
GRUB_DISABLE_RECOVERY="true"
```

重点选项代表的意义如下:

- GRUB_TIMEOUT: 设置在选择菜单等待超时秒数.设为0表示不等待,设为-1表示必须手动选择.

- GRUB_TIMEOUT_STYLE: 可以设置的值为menu,countdown,hidden等,默认为menu.这个参数也就是设置要不要显示菜单.设置为countdown或者hidden会让用户看不到任何内容.

- GRUB_DEFAULT: 菜单默认选择项目,可以设置的值有saved,数字,title名,ID名等,依据menuentry的设置而定.

  例如在配置中定义了三条menuentry:

  ```sh
  menuentry 'CentOS' --unrestricted $menuentry_id_option 'linux-1'
  menuentry 'Debian' --unrestricted $menuentry_id_option 'gnulinux'
  menuentry 'Windows' --unrestricted $menuentry_id_option 'win'
  ```

  那么对应GRUB_DEFAULT的值:

  - 值为1表示选用排在第2个定义的Debian系统,因为数字编号从0开始算.

  - 值为win表示选择排在第3个定义的Windows系统,通过id选的值.

  - 值为saved表示使用grub2-set-default来设置哪个为默认值,通常默认为0.

- GRUB_TERMINAL_OUTPUT: 信息输出的终端模式,可以设置值有console,serial,gfxterm,vga_text等.

- GRUB_CMDLINE_LINUX: 内核的外加参数功能,用来设置内核启动时还需要额外加入的参数.

例如修改菜单等待时间为30秒,之后用grub2-mkconfig来重建grub.cfg:

```sh
[root@101c7 ~]# sed -i 's/GRUB_TIMEOUT=5/GRUB_TIMEOUT=30/g' /etc/default/grub ; head -1 /etc/default/grub
GRUB_TIMEOUT=30
[root@101c7 ~]# grub2-mkconfig -o /boot/grub2/grub.cfg
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-3.10.0-1160.41.1.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-1160.41.1.el7.x86_64.img
Found linux image: /boot/vmlinuz-3.10.0-862.el7.x86_64
Found initrd image: /boot/initramfs-3.10.0-862.el7.x86_64.img
Found linux image: /boot/vmlinuz-0-rescue-77a36143eb014dd5a0d6e738b1d84778
Found initrd image: /boot/initramfs-0-rescue-77a36143eb014dd5a0d6e738b1d84778.img
done
[root@101c7 ~]# grep timeout /boot/grub2/grub.cfg
if [ x$feature_timeout_style = xy ] ; then
  set timeout_style=menu
  set timeout=30
# Fallback normal timeout code in case the timeout_style feature is
  set timeout=30
```

再看一看/etc/grub.d文件夹的内容:

```sh
[root@101c7 ~]# ll /etc/grub.d
total 72
-rwxr-xr-x. 1 root root  8702 Mar 16  2021 00_header
-rwxr-xr-x. 1 root root  1043 Mar 21  2019 00_tuned
-rwxr-xr-x. 1 root root   232 Mar 16  2021 01_users
-rwxr-xr-x. 1 root root 10781 Mar 16  2021 10_linux
-rwxr-xr-x. 1 root root 10275 Mar 16  2021 20_linux_xen
-rwxr-xr-x. 1 root root  2559 Mar 16  2021 20_ppc_terminfo
-rwxr-xr-x. 1 root root 11169 Mar 16  2021 30_os-prober
-rwxr-xr-x. 1 root root   214 Mar 16  2021 40_custom
-rwxr-xr-x. 1 root root   216 Mar 16  2021 41_custom
-rw-r--r--. 1 root root   483 Mar 16  2021 README
```

可以看到文件名刚好和grub.cfg中段头对应.主要文件有:

- 00_header: 主要在创建初始的显示项目,包括需要载入的模块分析,屏幕终端格式,倒数秒数,菜单是否要隐藏等,大部分在/etc/default/grub里面设置的变量,用到这个脚本里用来重建grub.cfg.
- 01_users: 设置账号密码,用来管控每个菜单选项进入权限.权限用在menuentry中有三种:不受限(unrestricted),用户(users),超级用户(superusers).其中只有超级用户可以使用启动项编辑模式.

- 10_linux: 根据分析/boot下面的文件,尝试找到正确的Linux内核文件与虚拟文件系统镜像等,脚本会将找到的文件路径写入到grub.cfg中.因为每一个核心文件都会建立一个启动选项,所以可以适当删除旧核心文件来精简启动菜单.

- 30_os-prober: 这个脚本用来找其他分区中可能存在的操作系统,如果找到则将其加入启动菜单中.可以在/etc/default/grub中加上`GRUB_DISABLE_OS_PROBER=true`参数来取消这一扫描.

- 40_custom: 用来手动添加菜单项目.例如想新增一个menuentry来指定开机进入图形模式,可以在grub.cfg中复制一个menuentry段,修改对应的title,id与linux16后面的参数(增加 systemd.unit=graphical.target),然后再用grub2-mkconfig命令重建grub.cfg即可.

### 设置多重引导

多重引导使用的叫开机管理程序的链接(Chain Loader)功能,将开机引导程序指向另外的地方.只需要设置另一个开机引导程序所在分区代号和所在扇区就行.

假设系统有一块硬盘两个分区,分别装了Linux(sdb1)和Windows(sdb2),那么我们需要增加两个开机选项,一个指向Windows开机菜单,一个回到MBR的默认环境,40_custom文件内容大致是这样:

```sh
[root@101c7 ~]# vi /etc/grub.d/40_custom 
#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the 'exec tail' line above.
menuentry 'Windows' --id 'win' {
        insmod chain
        insmod ntfs
        set root=(hd0,msdos2)
        chainloader +1
menuentry 'MBR' --id 'mbr' {
        insmod chain
        set root=(hd0)
        chainloader +1
"/etc/grub.d/40_custom" 14L, 469C written

```

其中最重要的是载入chain和ntfs模块,由此grub2才能正确读取文件系统执行Chain Loader功能.

### 启动项编辑模式

在启动菜单出现后,可以按e进入启动项编辑模式.也就是直接编辑grub.cfg文件内容.

例如可以在systemd.unit中指定为rescue.target,这样就能直接进入救援模式,而不需要先进入系统.修改完毕后用快捷键[Ctrl]+x来执行



## 启动异常处理

通常因为某些不正常的设置或不正常关机导致无法顺利开机时,可以进入rescue模式去处理.

### 忘记root密码

在使用grub做引导的系统可以这样处理:

1. 启动系统在选择启动项的界面下,按e进入默认启动项grub编辑模式.
2. 移动到有kernel那行,再按一次e进入编辑界面,在最后方输入`single`.
3. 按下回车,再按下b就可以进入单用户维护模式.
4. 这一模式下可以直接用`passwd`命令修改root密码.

CentOS 7中rescue模式也需要root密码才能登录,因此可以进入emergency救援模式:

1. 按e进入编辑默认启动项grub,找到linux16那行在最末尾输入`init=/bin/sh`,按[Ctrl]+x执行;
2. 进入emergency模式后,输入`mount -o remount,rw /`命令将根目录挂载为可读写模式;
3. 然后使用`passwd`命令设置新的root密码;
4. 最后输入`touch /.autorelabel`更新系统信息,让SELinux生效;
5. 执行`exec /sbin/init`或`reboot`即可退出救援模式.

通过rd.break(Ram Disk里面的操作系统)内核启动参数也可以处理:

1. 同样在编辑默认启动项grub,在linux16那行末尾加入`rd.break`参数,按[Ctrl]+x执行;
2. 此时进入的是Ram Disk环境,系统被挂载到/sysroot目录下,用`mount -o remount,rw /sysroot`重新挂载;
3. 用命令`chroot /sysroot`来切换根目录,并使用`passwd`命令修改密码;
4. 同样用`touch /.autorelabel`来变回SELinux的安全标签.重启即可.

touch /.autorelabel命令的作用:

- 在救援模式下系统没有SELinux,所以用passwd命令修改了/etc/shadow文件后,它的SELinux安全标签会被取消,在SELinux为Enforcing模式下会无法登录系统.

- 创建/.autorelabel文件就是要让系统在开机时自动使用默认SELinux类型重写入SELinux安全标签到每个文件.

- 如果不想让每个文件都更新标签,可以改完密码后,将SELinux运行模式改为permissive(修改/etc/selinux/config文件).再重新开机后运行`restorecon -Rv /etc`仅恢复/etc目录下的默认安全上下文类型.最后将SELinux配置文件的运行模式改回enforcing,用`setenforce 1`来生效.

### 文件系统错误

断电或不正常关机会导致文件系统错误,通常是软件数据问题,如果根目录没有损坏,可以进入维护模式下使用fsck命令修复ext4格式的分区,修复完毕后以reboot重启即可:

```sh
[root@101c7 ~]# fsck /dev/sda2
fsck from util-linux 2.23.2
```

如果是xfs格式分区则使用xfs_repair命令:

```sh
[root@101c7 ~]# xfs_repair /dev/sda2
xfs_repair: cannot open /dev/sda2: Device or resource busy
```

如果整个硬盘只有一个大区,那文件系统错误一定是根目录的问题.这时候需要将硬盘拔下来,接到另外一台Linux系统的机器上,并且不要挂载,以root身份执行fsck或xfs_repair命令修复.

还有一种方法是使用U盘刻成Live CD,在U盘启动的系统中执行修复命令.



## 关机重启

切换运行级别和模式并不会重启.

### 查看用户在线状态

如果有别的用户在线,强制关机可能会造成用户文件丢失,可以先使用*who*查看当前已登录的用户信息:

```shell
[user1@101c7 root]$ who -Hu
NAME     LINE         TIME             IDLE          PID COMMENT
root     tty1         2021-09-11 09:35  old          897
root     pts/0        2021-09-15 12:12   .          5334 (192.168.2.101)
root     pts/1        2021-09-14 08:40  old        55207 (192.168.2.101)
```

### 数据写回

默认情况下,某些依据加载内存中的数据将不会直接被写回硬盘,而是暂存在内存,可以手动同步将数据写入.

立即运行同步操作:

```shell
[user1@101c7 root]$ sync
```

使用重启关机命令前也会自动调用*sync*命令.

当非管理员使用*sync*命令时,只会更新操作用户的数据.

### 关机操作

通常使用*shutdown*命令来进行关机操作.

~~关机命令必须加入时间参数,否则会自动跳到run-level 1(单用户维护)的登录情况~~

立马关机:

```shell
[user1@101c7 root]$ shutdown -h now
```

预定在21:00关机.如果当前时间超过21:00则会在隔天21:00才关机:

```shell
[user1@101c7 root]$ shutdown -h 21:00
```

预定2分钟后关机,并发送消息:

```shell
[root@101c7 ~]# shutdown -P 120 "will  poweroff"
Shutdown scheduled for Wed 2021-09-15 16:01:48 EDT, use 'shutdown -c' to cancel.
```

取消即将进行的关机操作:

```shell
[root@101c7 ~]# shutdown -c
[root@101c7 ~]# 
Broadcast message from root@101c7 (Wed 2021-09-15 14:01:54 EDT):

The system shutdown has been cancelled at Wed 2021-09-15 14:02:54 EDT!
```

### 重启操作

重启命令可用*reboot*或*halt*,选择其一即可.

立马强制关机:

```shell
[root@101c7 ~]# halt -P -f
```

同步后重启系统:

```shell
[root@101c7 ~]# sync; sync; sync; reboot
```

### 切换执行等级

可以通过init命令来切换运行等级,例如进入单用户维护模式:

```shell
[root@localhost ~]# init 1
Broadcast message from root@localhost.localdomain on pts/1 (Fri 2019-07-05 15:40:59 CST):

The system is going down to rescue mode NOW!
```

在CentOS7中则是由systemctl来管理模式之间的切换,例如切换到救援模式:

```sh
[root@101c7 ~]# systemctl isolate rescue.target
```



