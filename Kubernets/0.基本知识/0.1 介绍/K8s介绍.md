# K8s介绍

## 单体应用

单体应用由很多个组件组成,这些组件紧密地耦合在一起,由于它们在同一个操作系统进程中运行,所以在开发,部署和管理地时候必须以同一个实体进行.

对单体应用来说,即使是某个组件的一个小修改,都需要重新部署整个应用.组件之间缺乏严格边界,互相依赖,系统复杂度逐渐提升.

运行一个单体应用,通常需要一台能为整个应用提供足够资源的高性能服务器.为了应对不断增长的系统负荷,需要垂直扩展,对服务器硬件进行升级.或者增加更多服务器做水平扩展.垂直扩展通常会有性能瓶颈,水平扩展可能需要大量改动原本应用程序代码.



## 微服务

微服务构架是为了解决大型单体应用臃肿的问题,将单体应用拆分为小的可独立部署的微服务组件.每个微服务以独立的进程运行,并通过简单且定义良好的API接口与其他微服务通信.

服务器之间通过类似HTTP这样的同步协议通信,或者像AMQP这样的异步协议通信.使用这些标准化协议,使得微服务可以不限开发语言实现.只要能提供相对静态的API,改动一个微服务不会对其他微服务产生影响.

使用微服务另外一个好处是,能根据需要针对单个组件进行水平扩容,对没法水平扩容的组件进行垂直扩容,组合方式非常灵活,可以适应不同的环境.

微服务也有缺点.当组件数量增加时,组件部署的组合数和依赖的组合数也在增加,配置工作变得冗杂且易错.还因为微服务跨多个进程和服务器,使得调试代码和定位异常调用变难.



## K8s介绍

Kubernetes源于谷歌内部的Borg,是一个面向应用的容器集群部署和管理系统.Kubernetes的目标旨在消除管理计算,网络和存储这些基础设施的负担,将底层基础设施抽象,这样做同时简化了应用的开发,部署,以及对开发和运维团队的管理.K8s还提供基础平台,用于构建定制化的工作流程和高级的自动化任务.

从运维角度来看,只要服务器上部署了K8s,不再需要安装其他依赖服务就能运行应用程序.Kubernetes具有以下几个重要特性:

- 自动装箱

  构建于容器之上,基于资源依赖及其他约束自动完成容器部署且不影响其可用性.通过调度机制混合关键型应用和非关键型应用的工作负载于同一节点以提升资源利用率.在K8s中所有工作节点公开为一个部署平台,开发人员不需要了解组成集群的服务器.如果需要使用一些特性节点来运行程序,可以通过节点标签来选择.

- 健康检查和自我修复

  K8s会监控应用程序组件和运行节点,支持容器故障后自动重启,节点故障后重新调度容器,健康状态检查失败后重新创建等自愈机制.

- 水平扩展

  支持通过简单的命令手动水平扩展.以及基于硬件资源负载率的自动水平扩展机制.如K8s运行在云基础设施上,可以根据程序使用资源情况和需要,自动添加或缩减节点.

- 服务发现和负载均衡

  K8s通过KubeDNS(或CoreDNS)为系统内置了服务发现功能.它为每个Service配置DNS名称,允许集群内的客户端直接使用名称访问,而Service则通过iptables或ipvs内建了负载均衡机制.

- 自动发布和回滚

  K8s支持灰度更新应用程序或配置信息.它会确保实例不会同时停止,一旦有故障发生,会立即自动执行回滚.

- 密钥和配置管理

  K8s的ConfigMap实现了配置数据与Docker镜像分离,对配置做出变更时无需重构镜像.此外对于敏感数据如密码和密钥等,有专门的Secret对象来存放.

- 存储编排

  K8s支持pod对象按需自动挂载不同类型的储存系统,比如本地储存,云储存和网络储存系统.

- 批量处理执行

  除了服务型应用,K8s还支持批处理作业和持续集成.



## 资源对象

K8s中的基本概念和术语大多围绕着资源对象(Resource Object)来说,资源对象可分为两类:

- 某种资源的对象,例如Node, Pod, Service, Volume等.
- 与资源对象相关的事物与动作,例如Label, Namespace, PVC, HPA等.

资源对象一般包括几个通用属性:

- 版本

  在版本信息中包括此对象所属的资源组,一些资源对象属性根据不同版本不同.

- 类别

  用于定义资源对象的类型.

- 名称

  资源对象的名称必须唯一.

- 标签

  资源对象的标签可以用来表明资源的特征类别,以及通过标签筛选不同资源对象来进行操作.

- 注解

  可以理解为一种特殊的标签,常用于实现资源对象属性的自定义扩展.
