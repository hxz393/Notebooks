# 服务资源

## 基本操作

服务services使用标签来选择Pod.下面简称SVC.

### 创建SVC

假设已经启动了一组Pod,标签为app=kubia.可以通过命令kubectl expose来创建服务,不过推荐使用YAML文件:

```sh
[root@server4-master ~]# vi kubia-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: kubia
spec:
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: kubia
```

其中80端口用来给外界访问,8080映射容器端口,并通过标签选择Pod.

创建并查看服务:

```sh
[root@server4-master ~]# kubectl create -f kubia-svc.yaml 
[root@server4-master ~]# kubectl get svc
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE
kubernetes   ClusterIP   10.96.0.1        <none>        443/TCP   17h
kubia        ClusterIP   10.107.244.106   <none>        80/TCP    8s
```

可以看到服务已经分配了一个内部集群的IP地址10.107.244.106,访问端口为80.

### 测试服务

由于是内部集群地址,只有集群中的Pod可以访问.可以使用kubectl exec命令在Pod中执行curl命令:

```sh
[root@server4-master ~]# kubectl exec kubiaex-f4wkw -- curl -s 10.107.244.106
You've hit kubiaex-nj968
[root@server4-master ~]# kubectl exec kubiaex-f4wkw -- curl -s 10.107.244.106
You've hit kubiaex-ptws9
```

从结果可以看到访问连到后端随机一个Pod中.

### 亲和性

可以配置会话亲和性,这样会使服务代理将同IP的请求转发到同一个Pod中:

```sh
[root@server4-master ~]# vi kubia-svc.yaml
spec:
  sessionAffinity: ClientIP
```

由于K8s服务不是在HTTP层面上工作,它只处理TCP和UDP包,所以会话亲和性不能基于cookie

### 暴露多端口

可以在服务中暴露多个端口.必须设置端口名称:

```sh
[root@server4-master ~]# vi kubia-svc.yaml
spec:
  ports:
  - name: http
    port: 80
    targetPort: 8080
  - name: https
    port: 443
    targetPort: 8443
```

### 命名引用

如果Pod配置中对端口取了名:

```sh
[root@server4-master ~]# vi kubia-rs.yaml
spec:
  containers:
    ports: 
    - name: http
      containerPort: 8080
    - name: https
      containerPort: 8443
```

那么在服务配置中可以直接引用:

```sh
[root@server4-master ~]# vi kubia-svc.yaml
spec:
  ports:
  - name: http
    port: 80
    targetPort: http
  - name: https
    port: 443
    targetPort: https
```

这样即使容器更换端口号也无须更改服务的配置.



## 服务发现

服务可以提供稳定的IP地址来访问Pod,只要服务存在IP就不会变.但客户端Pod要获得服务的IP和端口需要配置.

### 环境变量

如果服务先于Pod创建,Pod创建时K8s会初始化一系列环境变量指向现存的服务,Pod上的进程可以根据环境变量获得服务的IP地址和端口号.

重新运行Pod后再查看环境变量:

```sh
[root@server4-master ~]# kubectl delete -f kubia-rs.yaml 
[root@server4-master ~]# kubectl create -f kubia-rs.yaml 
[root@server4-master ~]# kubectl exec kubiaex-5s68q -- env
KUBIA_PORT=tcp://10.107.244.106:80
KUBIA_SERVICE_HOST=10.107.244.106
KUBIA_SERVICE_PORT=80
KUBIA_PORT_80_TCP_PROTO=tcp
KUBIA_PORT_80_TCP_ADDR=10.107.244.106
KUBIA_PORT_80_TCP=tcp://10.107.244.106:80
KUBIA_PORT_80_TCP_PORT=80
```

上面显示的就是创建服务之后才有的环境变量,指向了服务kubia的IP地址和端口.此外还有kubernetes服务的环境变量.

### DNS

K8s使用coredns作为默认的DNS服务,每个运行的Pod都会在/etc/resolv.conf中写入DNS服务的地址:

```sh
[root@server4-master ~]# kubectl -n kube-system describe service/kube-dns
IP:                10.96.0.10
[root@server4-master ~]#  kubectl exec -it kubiaex-5s68q -- bash
root@kubiaex-5s68q:/# cat /etc/resolv.conf 
nameserver 10.96.0.10
search default.svc.cluster.local svc.cluster.local cluster.local
options ndots:5
```

Pod是否使用内部DNS策略由spec.dnsPolicy来决定:

```sh
[root@server4-master ~]# kubectl get po kubiaex-5s68q -o yaml
spec:
  dnsPolicy: ClusterFirst
```

客户端的Pod在知道服务名称的情况下可以通过FQDN来访问而不是依靠环境变量.例如svc的全名是kubia.default.svc.cluster.local,通过Pod中容器去访问这个地址:

```sh
root@kubiaex-5s68q:/# curl http://kubia.default.svc.cluster.local
You've hit kubiaex-bwzb9
```

FQDN分为三部分:kubia为主机名, default为对应命名空间, svc.cluster.local是所有集群本地服务名称中使用的可配置集群域后缀.

如果要通信的资源在一个命名空间下,可以省略后缀,直接通过主机名通信:

```sh
root@kubiaex-5s68q:/# curl http://kubia  
You've hit kubiaex-bwzb9
root@kubiaex-5s68q:/# ping kubia
PING kubia.default.svc.cluster.local (10.107.244.106): 56 data bytes
```



## 指向外部服务

SVC也可以将服务的地址重定向到集群外部的网络地址和端口,在集群中的Pod可以像连接内部服务一样连接到外部服务.

### Endpoint

SVC通过Endpoint(下面简称EP)资源来和Pod连接,一般指向Pod的IP地址和端口列表:

```sh
[root@server4-master ~]# kubectl describe svc kubia
Endpoints:         10.244.191.210:8080,10.244.191.211:8080,10.244.244.209:8080
```

也可以直接查询EP资源:

```sh
[root@server4-master ~]# kubectl get endpoints kubia
NAME    ENDPOINTS                                                     AGE
kubia   10.244.191.210:8080,10.244.191.211:8080,10.244.244.209:8080   100m
[root@server4-master ~]# kubectl describe endpoints kubia
Name:         kubia
Namespace:    default
Labels:       <none>
Annotations:  endpoints.kubernetes.io/last-change-trigger-time: 2021-11-03T11:45:07Z
Subsets:
  Addresses:          10.244.191.210,10.244.191.211,10.244.244.209
  NotReadyAddresses:  <none>
  Ports:
    Name     Port  Protocol
    ----     ----  --------
    <unset>  8080  TCP
```

EP的作用就是储存通过Pod选择器得到的Pod地址和端口,提供给服务调用.

### 配置EP

可以分别创建SVC和EP资源来自定义要转发到地址列表.先创建一个没有选择器的服务:

```sh
[root@server4-master ~]# vi outside-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: outside
spec:
  ports:
  - name: http
    port: 80
```

创建一个EP来指定地址列表 .名称需要和SVC的一致:

```sh
[root@server4-master ~]# vi outside-ep.yaml
apiVersion: v1
kind: Endpoints
metadata:
  name: outside
subsets:
  - addresses:
    - ip: 11.11.11.11
    - ip: 22.22.22.22
    ports:
    - port: 80
```

分别部署后,SVC就具有了转发到外部服务的功能:

```sh
[root@server4-master ~]# kubectl create -f outside-svc.yaml -f outside-ep.yaml 
```

自定义Endpoint通常可用于服务迁移.当集群内的应用迁移到外部时,修改EP资源中的地址后,SVC提供的访问IP地址可以保持不变.

### 配置别名

除了手动配置EP外,还可以设置域名作为转发目标.只需要在SVC配置文件中设置类型为ExternalName即可:

```sh
[root@server4-master ~]# vi ext-svc.yaml
apiVersion: v1
kind: Service
metadata:
  name: exten
spec:
  type: ExternalName
  externalName: someapi.somecompany.com
  ports:
  - port: 80
    targetPort: 6379
[root@server4-master ~]# kubectl create -f ext-svc.yaml 
[root@server4-master ~]# kubectl get svc exten 
NAME    TYPE           CLUSTER-IP   EXTERNAL-IP               PORT(S)   AGE
exten   ExternalName   <none>       someapi.somecompany.com   80/TCP    29s
```

之后集群内的Pod可以通过访问exten这个SVC就能连接到外部域名someapi.somecompany.com.

这样的好处是不需要关心外部域名的IP地址,即使IP有变动也不会影响SVC的运行.



## 暴露内部服务

