# 基础概念

## 虚拟化技术

虚拟化技术是计算机资源的一种管理技术,它掌控着计算机硬件资源,并将其抽象化,通过统一形式展现给应用程序.对用户来说,虚拟化只是定义了为程序隐藏真实环境的方式,真正实现虚拟化还需要具体的执行虚拟化过程的程序.

虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化.

- 硬件虚拟化需要搭配专门的硬件平台,与普通硬件设备存在兼容问题.但有个好处是对硬件利用率高.

- 软件虚拟化通常在应用程序和硬件资源搭建一个Hypervisor层,应用程序在虚拟化环境中对资源的调用,是通过Hypervisor层提供的调用接口来操作.JAVA虚拟机(JVM, Java Virtual Machine)就是通过此方式实现跨平台运行.

软件虚拟化从对象所在的层次,又分应用虚拟化(例如手机模拟器,Wine等)和平台虚拟化.比较常见的平台虚拟化分为以下几类:

- 完全虚拟化

  虚拟机模拟完整的底层硬件环境和特权指令的执行过程.例如VMware Workstation, VirtualBox, QEMU等

- 硬件辅助虚拟化

  利用CPU辅助支持(例如Intel-VT,AMD-V)处理敏感指令来实现完全虚拟化的功能,例如VMware, Xen, KVM等.

- 部分虚拟化

  只针对部分硬件资源进行虚拟化,客户操作系统需要进行修改.

- 超虚拟化(Paravirtualization)

  部分硬件接口以软件的形式提供给客户机操作系统,例如早期的Xen.

- 操作系统级虚拟化

  内核通过创建多个虚拟的操作系统实例来隔离不同的进程,例如容器相关技术.

传统在硬件层实现的虚拟化,需要有额外的虚拟机管理应用和虚拟机操作系统层.Docker容器是在操作系统层面上实现虚拟化,直接复用本地主机的操作系统,因此叫做轻量级.



## 云服务类型

提供云服务的公司总体可以归为以下几大类的一种或多种:

- IaaS

  基础设施即服务(IaaS, Infrastructure as a service)指在云端为用户提供基础设施,如虚拟机,服务器,储存,负载均衡和网络等,代表有AWS和阿里云.

- PaaS

  平台即服务(PaaS, Platform as a service)指在云端为用户提供可执行环境,数据库,网站服务器和开发工具等,代表有OpenShift, Google App Engine, dotCloud等.

- SaaS

  软件即服务(SaaS, Software as a service)指在云端为用户提供软件,如CRM系统,邮件系统,在线办公等.代表有微软Office 365, 有道, Tower等.

- CaaS

  容器即服务(CaaS, Container as a service)是虚拟云主机的升级版,用容器替代虚拟机的服务模式.

IaaS, Paas和SaaS是云计算最基本的三种服务模式,客户通过云客户端来访问上面的服务.



## Docker运行基础

Docker主要使用的技术有Libcontainer, Namespaces, CGroups和AUFS.

### Namespaces

内核命名空间(Namespaces)是Linux下资源隔离机制.它将进程,进程组,IPC,网络,内存等资源变得不再是全局性资源,将资源从内核层面分属于某个特定Namespace,不同Namespace之间资源互相透明不可见.

Docker使用以下Namespace:

- PID Namespace: 用于进程隔离,让容器拥有自己独立的一套PID.
- NET Namespace: 用于管理网络接口,让容器拥有自己的独立网卡.
- IPC Namespace: 用于管理进程间通信,让容器拥有自己的共享内存和semaphore.
- MNT Namespace: 用于管理挂载点,让容器看上去拥有整个文件系统.
- UTS Namespace: 用于隔离内核和版本信息,让容器拥有独自的hostname.
- USER Namespace: 用于管理用户,让容器拥有独立于宿主机的用户.

### CGroups

控件群组(CGroups, Control Groups)可以限制,记录,调整进程组所使用的物理资源.例如给某进程多分配一些CPU资源或限制使用的内存上限.Linux有了CGroups资源管理机制,内核虚拟化才成为可能.

### LXC

Linux容器(LXC, Linux Containers)就是基于Linux内核通过调用CGroups和Namespaces来实现容器轻量级虚拟化的技术.同时,LXC也是一组面向Linux内核容器的用户态API接口.用户通过LXC提供的功能可以创建一套完整且互相隔离的虚拟应用运行环境.

在LXC的实现中,运行在容器中的程序访问的是真实物理机系统,与通过虚拟机实现的虚拟化比,消除了Hypervisor层,大大提高了运行效率.

### Libcontainer

Docker采用libcontainer作为默认容器,取代了之前的LXC.libcontainer的隔离性主要是内核的命名空间来实现的,具体有pid,net,ipc,mnt和uts等命名空间,它们将容器的进程,网络,消息,文件系统和主机名进行隔离.

### AUFS

UnionFS是一个堆栈式的联合文件系统,AUFS原名Another UnionFS,是对UnionFS的补充.随着AUFS发展后更名为高级多层次统一文件系统(Advanced Multi Layered Unification Filesystem).简单来说就是可以将分布在不同地方的目录挂载到同一个虚拟文件系统中.

Docker参考Linux启动过程,将一个readonly权限的bootfs(虚拟文件系统)挂载到容器文件系统中,然后通过AUFS将readonly权限的rootfs(根目录文件系统)添加到bootfs之上.之后每次挂载一个readonly的FS文件层,将用户所要使用的文件内容挂载到rootfs之上.

这些文件层就是堆栈式文件系统中所保存的数据,在AUFS中每个文件层叫做一个分支,整个文件系统称为联合文件系统.而AUFS就是用来管理,使用这些文件层的文件系统.

Docker利用AUFS加载完最高层之后,会在最上面再添加一个rw权限的FS层.容器内部的应用,对当前文件系统所有写操作都会保存在这个FS层当中,当使用commit命令后,Docker会将这个FS层中的数据作为单独一个文件层保存在AUFS之中.

镜像(Image)可以理解为特定FS层的集合.从镜像启动容器(Container)时,Docker会依次加载BaseImage和其上image.通过镜像分隔为AUFS的文件层,使得所有容器可以共享文件层,且不会发生写冲突.



## Docker应用范围

Docker是基于Go语言实现的容器项目,由dotCloud于2013年正式开源,2015年开始大规模应用.

### 云平台

现在Docker主要应用于云平台.在Docker出现以前各云平台互不兼容,Docker屏蔽了硬件层的差异,提供了统一的用户应用层,企业产品因此可以在各种云平台之前自由迁移.

### Devops

Docker另外一个应用领域是Devops,只要使用相同的数据镜像,就不用考虑环境问题,减少了代码运行差异,使得开发团队可以集中于产品开发,无需注重流程.

Docker的标准化规范,弥补了开发,业务和运维三方的需求差异,可以无缝地将产品在开发,测试和生产环境之间自由移动.



## Docker优缺点

总的来看Docker的缺点暂不构成问题,可以放心使用.

### 优点

使用Docker的优点有:

- **高资源利用率**

  传统虚拟机硬件资源独立不共享,Docker中所有容器共享同一个系统内核和硬件资源,对资源的利用率比虚拟机高得多.

- **支持跨节点部署**

  通过Docker定义的标准镜像数据格式,可以在不同操作系统和物理硬件环境中使用.

- **版本可控,组件可复用**

  Docker借助AUFS文件系统的特性,使得镜像与镜像之间可以互相借用组合,产生不同的镜像.并借助标签功能对镜像标注,为镜像提供版本控制功能.

- **共享镜像**

  Docker作为开源软件,构建出的镜像可以自由分发流传(主要通过Docker hub).

- **轻量级,易维护**

  Docker在Linux系统中表现为一个普通的进程,因此管理非常容易.

### 缺点

Docker的缺点有:

- **宿主资源没有完全做到隔离**

  虽然容器使用的系统资源互相隔离,但还有一些内核资源未被隔离开来.例如/proc, /sys这些目录和SELinux, syslog这些内核功能.因此容器和宿主机共用内核版本,容器内不能升级内核,对内核版本有要求的应用可能不兼容Docker.

- **GO语言尚不成熟**

  由于Docker全部采用Golang来编写,而Golang还比较年轻,难保不发生大的变动.这将对Docker产生连带影响.

- **控制权问题**

  虽然Docker现在开源,但事实上被一家公司所控制,而不像其他大的开源项目有公共基金会管理.因此后续可能变为收费闭源项目.



## Docker构架

Docker是一个客户端/服务器(C/S)构架的程序.客户端只需要通过Socket向服务器或守护进程(Docker引擎)发送请求,服务器或守护进程将完成所有工作并返回结果.

Docker提供了一个命令行工具docker以及一套RESTful API来与守护进程交互.用户可以在一台主机上运行Docker守护进程和客户端,也可以从本地Docker客户端连接到运行在另一台主机上的远程Docker守护进程.



## Docker镜像

镜像类似于虚拟机的镜像,可以将它理解为一个只读模板,保存着容器需要的环境和应用的执行代码.

镜像是创建Docker容器的基础,不同的镜像对应着不同的应用程序或服务.

### 镜像名称

镜像名称格式像这样: `[命名空间|仓库地址]/镜像名:标签`

- 命名空间(Namespace)

  用于区别构建镜像的组织或个人,一般为Docker Hub上的用户名.没有命名空间的镜像代表由官方提供,交由可靠且权威的第三方组织或机构维护的官方镜像.

- 仓库地址(URL)

  如果镜像放置在第三方或私有仓库中,命名空间部分使用仓库URL路径来命名.

- 镜像名(Repository)

  通常采用这个镜像中所包含的应用程务或服务名字作为镜像名.

- 标签(Tag)

  习惯采用镜像包含的应用程务或服务的版本来作为镜像标签.

### 镜像分层

Docker的镜像是一个多层结构,每一层都在原有层基础上进行改动.镜像最底层为启动文件系统(bootfs)镜像,再往上一层根镜像(rootfs)通常是操作系统,用户镜像构建于根镜像之上.

与Git原理类似,每一层镜像都可被视为一个提交,并拥有独立ID,最顶层的ID被视为镜像ID(Image ID).镜像ID用64个十六进制字符串(256比特)用来表示.当不同镜像包括相同层时,本地仅存一份相同内容.

上层和下层有相同的文件和配置时,上层会覆盖下层,以上层的数据为准,用户看到的是一个叠加之后的文件系统.

### 写时复制

写时复制指复制某个数组或对象时,复制过程并不马上发生,而是先进行一些标记动作,只有需要对复制的数组或对象进行修改时,才真正复制出这个变量的副本.

Docker通过镜像运行容器时,并不马上把镜像内容复制到沙盒环境,而是直接把沙盒环境建立在镜像的基础上.容器运行的沙盒环境是镜像之上的一层临时可读写镜像层,也叫做thin类型容器层,镜像层以只读方式堆在容器层下方.

发生文件修改时,才会将原有镜像中需要被修改的文件复制到容器层中,修改后直接保存在容器层.AUFS中删除文件则是在容器层生成一个空白文件,用来代替镜像层对应文件,实现逻辑删除.



## Docker容器

容器是从镜像创建的应用运行实例,包含独立运行的一个或一组应用,以及运行环境.可以在容器中装入任何应用,所有应用的运行方式都一样,可以启动,开始,停止,删除等.同时可以在任何环境中运行容器,容器之间互相隔离.

从操作系统角度看,容器是运行在操作系统上的一个进程,只不过加入了对资源的隔离和限制.

### 容器设计

虽然容器中能运行多个进程或多个不同的程序,但容器只会绑定一个进程.所以容器设计上应该以一个应用程序为主体,其他程序作为主体程序的支援.

这样容器启动时,主体程序也会被启动,Docker会监视这个程序的主进程.进程退出时,容器也会停止运行.同样通过命令停止容器运行时,Docker会发送停止信号给主体程序,让程序结束.

### 启动流程

使用docker run命令创建启动容器的流程如下:

1. 执行docker run命令后,Docker会在本地搜索所需镜像,如果没找到则从远程仓库中搜索并下载到本地,如果找到了,直接使用本地镜像.
2. Docker使用指定镜像创建一个新容器并启动.启动后在只读镜像文件层上挂载一层可读写的容器层,用来记录改变的数据.
3. Docker为容器分配一个虚拟网络接口,并通过网桥的方式将该网络接口桥接到宿主机上去.然后从网桥地址池取出一个IP地址分配给容器虚拟网络接口.
4. Docker在新容器中运行指定的命令或程序,执行完毕后被自动终止.



## Docker仓库

Docker仓库是集中存放镜像文件的场所.

仓库注册服务器(Registry)是存放仓库的地方,往往有多个仓库地址,用来存放不同类型的资源.

### 仓库分类

根据所在位置,仓库可以分为本地仓库和远程仓库.

根据储存镜像公开分享与否,仓库可以分为公开仓库(Public)和私有仓库(Private).

### 仓库组成

镜像仓库主要由两部分组成:

- 镜像管理系统为镜像仓库提供类似代码库式的镜像存取和管理方式.
- 用户系统为镜像仓库中的镜像管理操作的授权提供支持.

### Docker Hub

Docker Hub是Docker官方提供的镜像仓库,目前为所有用户提供不限量的公开镜像托管服务.



## 相关链接

和Docker相关的网站:

- Docker官网: https://www.docker.com/
- Docker官方文档: https://docs.docker.com/
- Docker Hub: https://hub.docker.com/
- Docker源码: https://github.com/docker

