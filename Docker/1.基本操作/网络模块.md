# 网络模块

## 网络模式

Docker自带了三种常用的网络模式,只能用于同一宿主机内容器间通信.默认使用Bridge网络.

### 查看网络

可以通过docker network ls命令查看Docker中定义的网络:

```sh
[root@server4 ~]# docker network ls
NETWORK ID     NAME      DRIVER    SCOPE
3b3d933326d5   bridge    bridge    local
9c9f9149deef   host      host      local
76306c358978   none      null      local
```

进一步通过docker network inspect能查看网络详情:

```sh
[root@server4 ~]# docker network inspect bridge 
[
    {
        "Name": "bridge",
        "Id": "3b3d933326d5a4dc198970d76c88ae265a09aab3edd12c1eb44d141c769628c8",
        "Created": "2021-10-22T06:08:04.744492282+08:00",
        "Scope": "local",
        "Driver": "bridge",
```

每运行一个容器,都会在全局注册相关的网络信息.

### None网络

也就是没有网络,挂在这个网络下的容器除了lo没有网卡.可以给一些安全性要求高的单机应用使用.

### Host网络

使用host网络的容器中网络配置与host完全一样.用在一些对网络性能要求高应用中.另外一种用途是让容器可以直接配置宿主机网络,比如某些跨主机的网络解决方案.

由于和宿主机公用网络,所以需要考虑端口冲突问题.另外与宿主机同一子网的机器也能发现容器的存在.

### Bridge网络

Docker通过Network Namespace为每个容器建立了独立网络,形成完全与宿主机隔离的环境.

默认情况下,Docker会在宿主机上架设一个名为docker0的虚拟网桥,用来连接宿主机与容器.容器与docker0之间通过Veth Pair(Virtual Ethernet Pair)来连接,所有连接到docker0上的容器同属于一个子网中,而宿主机也通过虚拟网卡连接到了docker0上.

```sh
[root@server4 ~]# ifconfig docker0
docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fe80::42:b4ff:fe98:85d5  prefixlen 64  scopeid 0x20<link>
        ether 02:42:b4:98:85:d5  txqueuelen 0  (Ethernet)
        RX packets 794  bytes 2870284 (2.7 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 934  bytes 5709678 (5.4 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

### Overlay网络

如果docker容器运行在不同主机中,要跨主机通信,必须使用Overlay网络.

Overlay是一种虚拟交换技术,主要是解决不同IP地址段之间的网络通信问题.Docker使用的Overlay技术是借助于libnetwork实现的VXLAN.Overlay网络需要一个K-V服务器比如Consul, zookeeper或etcd来储存相关主机信息.



## 网络设置

### 创建网络

可以自建一个桥接网络mybridge,并设置被容器所使用,以此隔绝不相干的应用容器:

```sh
[root@server4 ~]# docker network create --driver bridge mybridge
83a3f95af6b114c139f8887f48ac4d5dca739bfc310b8b209c5336cf211706d1
[root@server4 ~]# docker run -it --rm --net=mybridge ubuntu:18.04 
root@b476cb94f196:/# 
```

自建网络时能使用--subnet和--gateway参数来自定义网段和网关.

删除没在使用的自建网络使用docker network rm命令:

```sh
[root@server4 ~]# docker network rm mybridge
```

### 端口映射

容器与宿主机通过docker0网桥沟通,而容器与外网访问可以通过docker0转发到宿主机外网网卡上,只要宿主机开启了端口转发功能,容器即可访问宿主机外部的网络:

```sh
[root@server4 ~]# sysctl net.ipv4.conf.all.forwarding
net.ipv4.conf.all.forwarding = 1
[root@server4 ~]# iptables -t nat -L -n
Chain DOCKER (2 references)
target     prot opt source               destination              
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0      tcp dpt:5000 to:172.17.0.3:5000
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0      tcp dpt:49156 to:172.17.0.5:8080
```

但是默认情况下外部网络无法访问容器,可以使用端口映射方式,将容器的端口与宿主机端口绑定,外部网络便能通过此端口访问容器中的应用和服务.

端口映射可以在建立镜像时使用-P参数,将容器需要暴露端口随机映射到主机空闲端口上(默认49000~49900端口):

```sh
[root@server4 ~]# docker run -d -P nginx
555e6a418454ecbb450e519e09ec483645d97d56569627b827e1b54781f6afde
[root@server4 ~]# docker inspect -f={{.NetworkSettings.Ports}} 555e6a41
map[80/tcp:[{0.0.0.0 49153} {:: 49153}]]
```

使用-p参数来固定要映射到的宿主机端口,可以指定端口类型为udp:

```sh
[root@server4 ~]# docker run -d -p 192.168.2.241:8001:80/udp nginx
38769e47eebdc96ce3f0eded75e6b8c3de90609e42f01a09148911dc4ea025bb
[root@server4 ~]# docker inspect -f={{.NetworkSettings.Ports}} 38769e47
map[80/tcp:[] 80/udp:[{192.168.2.241 8001}]]
```

### 容器连接

有时一个容器中运行的应用程序,需要与运行在另外一个容器中的应用程序通过网络交换数据,这时就需要通过容器连接来完成.

要设置容器间通信,可以在创建容器时使用--link参数指定要连接的容器,这样会打开对被连接容器的网络访问.

例如创建一个MySQL容器,并让一个Web服务容器连接到它:

```sh
[root@server4 ~]# docker run -d --name mysql --env='MYSQL_ALLOW_EMPTY_PASSWORD=1' mysql
[root@server4 ~]# docker run -d -p 80:80 -p 443:443 --name web --link mysql:db nginx
```

连接容器并不需要指明或映射被连接容器mysql的端口,被连接容器端口只在容器间的通信中使用,不会被暴露在外网中,也不会被其他容器访问到.建立连接唯一需要确保的条件是连接和被连接的容器都要处于运行状态.

另外为了避免连接容器名与连接容器内某些配置重名,Docker支持容器间使用别名进行连接.例如上面就使用db来作为容器mysql的别名.在web容器中可以使用db作为访问时的主机名.可以查看容器web中的/etc/hosts文件:

```sh
[root@server4 ~]# docker exec -it web cat /etc/hosts
127.0.0.1       localhost
172.17.0.4      db f2159e1085ed mysql
172.17.0.5      1286ab689c48
```

另外在web容器中,通过env命令能看到mysql容器的环境变量.

```sh
[root@server4 ~]# docker exec -it web env
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
HOSTNAME=1286ab689c48
TERM=xterm
DB_PORT=tcp://172.17.0.4:3306
DB_PORT_3306_TCP=tcp://172.17.0.4:3306
DB_PORT_3306_TCP_ADDR=172.17.0.4
DB_PORT_3306_TCP_PORT=3306
DB_PORT_3306_TCP_PROTO=tcp
DB_PORT_33060_TCP=tcp://172.17.0.4:33060
DB_PORT_33060_TCP_ADDR=172.17.0.4
DB_PORT_33060_TCP_PORT=33060
DB_PORT_33060_TCP_PROTO=tcp
DB_NAME=/web/db
DB_ENV_MYSQL_ALLOW_EMPTY_PASSWORD=1
DB_ENV_GOSU_VERSION=1.12
DB_ENV_MYSQL_MAJOR=8.0
DB_ENV_MYSQL_VERSION=8.0.27-1debian10
NGINX_VERSION=1.21.3
NJS_VERSION=0.6.2
PKG_RELEASE=1~buster
HOME=/root
```

### 域名解析

Docker服务端自带一个内嵌DNS服务器,使容器可以通过容器名来通信.

但使用Docker DNS有个限制,只能在用户自定义网络中使用.也就是说默认桥接网络docker0中是无法使用解析的.

### 加入网络

处于不同bridge网络的容器,虽然有互通路由表规则,但在容器内iptables中会隔离掉访问.可以通过添加一块联通对方网桥的网卡来通信.使用命令docker network connect来添加容器dshell中联通mybridge网桥的网卡:

```sh
[root@server4 ~]# docker network connect mybridge dshell
```

同时也能通过docker network disconnect命令随时将容器的网络与容器断开:

```sh
[root@server4 ~]# docker network disconnect mybridge dshell
```

### 加入容器

加入容器是一种另类的容器间通信方式,它可以使两个以上容器共享一个网络栈,共享网卡和配置信息.

使用加入容器功能除了可以让程序通过lo口高速通信外,还能用于监控网络程序的容器布置.

例如新建容器加入到容器dshell中:

```sh
[root@server4 ~]# docker run -it --network=container:dshell alpine
/ # ip addr show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
48: eth0@if49: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
103: eth1@if104: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth1
       valid_lft forever preferred_lft forever
```

