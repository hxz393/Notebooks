# 安装配置

## 前置条件

由于Docker运行于Linux内核中,因此对于系统要求如下:

- 系统必须位为64位操作系统;
- 系统内核版本需要大于3.10;
- 硬盘要足够大.

可以使用以下命令查询系统位数和内核版本:

```sh
[root@server3 ~]# uname -r
3.10.0-1160.42.2.el7.x86_64
```

Docker引擎分为两个版本,社区版本(CE, Community Edition)和企业版本(EE, Enterprise Edition).通常安装社区稳定版.



## 安装Docker

在之前安装过Docker的主机上,需要完全卸载后再安装.

全新安装需要先修改仓库配置,增加docker-ce安装源:

```sh
[root@server4 ~]# yum install -y yum-utils
[root@server4 ~]# yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
Loaded plugins: fastestmirror
adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
grabbing file https://download.docker.com/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo
repo saved to /etc/yum.repos.d/docker-ce.repo
```

假如要安装nightly或test版本,使用下面的命令来启用对应仓库.关闭使用--disable参数:

```sh
[root@server4 ~]# yum-config-manager --enable docker-ce-nightly
[root@server4 ~]# yum-config-manager --enable docker-ce-test
```

安装最新版docker-ce:

```sh
[root@server4 ~]# yum install - docker-ce docker-ce-cli containerd.io
```

要安装特定版本,可以使用yum list来查询:

```sh
[root@server4 ~]# yum list docker-ce --showduplicates | sort -r
docker-ce.x86_64            3:20.10.9-3.el7                    docker-ce-stable 
docker-ce.x86_64            3:20.10.9-3.el7                    @docker-ce-stable
docker-ce.x86_64            3:20.10.8-3.el7                    docker-ce-stable 
```

例如安装20.10.8版本:

```sh
[root@server4 ~]# yum install docker-ce-20.10.8 docker-ce-cli-20.10.8 containerd.io
```

Docker安装时会新建一个docker组,可以将普通用户加入此组,这样普通用户就能直接运行docker命令:

```sh
[root@server4 ~]# useradd -p user10 user10
[root@server4 ~]# su -l user10
[user10@server4 ~]$ docker image ls
Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get "http://%2Fvar%2Frun%2Fdocker.sock/v1.24/images/json": dial unix /var/run/docker.sock: connect: permission denied
[user10@server4 ~]$ su -c 'usermod -G docker user10'
[user10@server4 ~]$ docker image ls
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   3 weeks ago   13.3kB
```



## 更新Docker

在docker仓库源启用的情况下,使用yum upgrade来更新:

```sh
[root@server4 ~]# yum upgrade
```



## 卸载Docker

使用下面的命令完全卸载Docker旧版本及相关程序:

```sh
[root@server4 ~]# yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine
```

删除新版Docker引擎:

```sh
[user10@server4 ~]$ yum remove docker-ce docker-ce-cli containerd.io
```

删除Docker使用的库,镜像和容器等数据:

```sh
[root@server4 ~]# rm -rf /var/lib/docker
[root@server4 ~]# rm -rf /var/lib/containerd
```



## 启动Docker

启动服务与设置开机启动:

```sh
[root@server4 ~]# systemctl start docker
[root@server4 ~]# systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
```

启动之后使用hello-world镜像来测试Docker功能是否正常:

```sh
[root@server4 ~]# docker run hello-world
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
```



## 查询Docker版本

使用docker version命令来查询Docker服务端和客户端的版本:

```sh
[root@server4 ~]# docker version
Client: Docker Engine - Community
 Version:           20.10.9
 API version:       1.41
 Go version:        go1.16.8
 Git commit:        c2ea9bc
 Built:             Mon Oct  4 16:08:14 2021
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          20.10.9
  API version:      1.41 (minimum version 1.12)
  Go version:       go1.16.8
  Git commit:       79ea9d3
  Built:            Mon Oct  4 16:06:37 2021
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.4.11
  GitCommit:        5b46e404f6b9f661a205e28d59c982d3634148f8
 runc:
  Version:          1.0.2
  GitCommit:        v1.0.2-0-g52b36a2
 docker-init:
  Version:          0.19.0
  GitCommit:        de40ad0
```



## 查看Docker信息

可以使用docker info来查看Docker运行状态:

```sh
[root@server4 ~]# docker info
Client:
 Context:    default
 Debug Mode: false
 Plugins:
  app: Docker App (Docker Inc., v0.9.1-beta3)
  buildx: Build with BuildKit (Docker Inc., v0.6.3-docker)
  scan: Docker Scan (Docker Inc., v0.8.0)

Server:
 Containers: 1
  Running: 0
  Paused: 0
  Stopped: 1
 Images: 5
 Server Version: 20.10.9
 Storage Driver: overlay2
  Backing Filesystem: xfs
  Supports d_type: true
  Native Overlay Diff: true
  userxattr: false
 Logging Driver: json-file
 Cgroup Driver: cgroupfs
 Cgroup Version: 1
 Plugins:
  Volume: local
  Network: bridge host ipvlan macvlan null overlay
  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog
 Swarm: inactive
 Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc
 Default Runtime: runc
 Init Binary: docker-init
 containerd version: 5b46e404f6b9f661a205e28d59c982d3634148f8
 runc version: v1.0.2-0-g52b36a2
 init version: de40ad0
 Security Options:
  seccomp
   Profile: default
 Kernel Version: 3.10.0-1160.42.2.el7.x86_64
 Operating System: CentOS Linux 7 (Core)
 OSType: linux
 Architecture: x86_64
 CPUs: 16
 Total Memory: 3.682GiB
 Name: server4
 ID: 7YVL:YG7U:BI3Q:BOVZ:XRWD:7BQO:6H3R:2BUW:OCQO:7JKZ:2OWC:UL2Q
 Docker Root Dir: /var/lib/docker
 Debug Mode: false
 Registry: https://index.docker.io/v1/
 Labels:
 Experimental: false
 Insecure Registries:
  127.0.0.0/8
 Registry Mirrors:
  https://mirror.ccs.tencentyun.com/
 Live Restore Enabled: false
```



## 启动参数

Docker服务启动实际上是调用了dockerd命令,Docker Daemon常用启动参数如下:

| 参数                                | 说明                             |
| ----------------------------------- | -------------------------------- |
| --api-cors-header=""                | 设定远程访问API所需的cors-header |
| --authorization-plugin=[]           | 设置认证插件列表                 |
| -b, --bridge=""                     | 设置容器使用的网桥               |
| --bip=""                            | 设定网络桥IP和子网掩码           |
| -D, --debug=false                   | 启动Debug模式                    |
| -d, --daemon=false                  | 启动守护进程模式                 |
| --default-gateway=""                | 设置容器使用的IPv4网关           |
| --dns=[]                            | 设置容器使用的DNS服务器列表      |
| --default-ulimit=[]                 | 设定容器默认的ulimit参数         |
| -exec-opt=[]                        | 设定管理容器使用的参数           |
| --exec-root="/var/run/Docker"       | 设定exec-driver默认根目录地址    |
| --fixed-cidr=""                     | 设定容器使用的IPv4子网段         |
| -G, --group="Docker"                | 设定UNIX Socket文件用户所属组    |
| -g, --graph="/var/lib/Docker"       | 设定Docker服务运行时的根目录     |
| -H, --host=[]                       | 设定Docker服务监听地址           |
| --icc=ture                          | 允许容器之间互相通信             |
| --insecure-registry=[]              | 设定可信任仓库地址               |
| --ip=0.0.0.0                        | 设定绑定容器端口信息时的默认IP   |
| --ip-forward=true                   | 允许转发IPv4数据包               |
| --ip-masq=true                      | 允许IP伪装                       |
| --iptables=true                     | 允许修改iptables规则             |
| --ipv6=true                         | 允许使用IPv6网络                 |
| -l, --log-level="info"              | 设定日志输出等级                 |
| --label=[]                          | 按照Key=Value设定Daemon标签      |
| --log-driver="json-file"            | 设定日志驱动格式                 |
| --log-opt=[]                        | 设定日志记录驱动参数             |
| --mtu=0                             | 设定容器MTU值                    |
| -p, --pidfile="/var/run/Docker.pid" | 设定Docker.pid文件路径           |
| --registry-mirror=[]                | 设定优先访问的仓库镜像地址       |
| -s, --storage-driver=""             | 设定数据储存驱动方式             |
| --selinux-enabled=false             | 启动SELinux                      |
| --storage-opt=[]                    | 设定数据储存驱动参数             |
| --tls=false                         | 启动TLS安全认证                  |
| --tlscacert="~/.Docker/ca.pem"      | 设定CA证书位置                   |
| --tlscert="~/.Docker/cert.pem"      | 设定TLS证书位置                  |
| --tlskey="~/.Docker/key.pem"        | 设定TLS密钥位置                  |
| --tlsverify=false                   | 启动TLS来验证远程访问请求        |
| --userland-proxy=true               | 启动指定的网络代理               |
| -v, --version=false                 | 输出Docker版本信息               |

如果参数后有[]标记,代表此参数可以使用多次.例如开启Debug模式,并监听本地2376端口:

```sh
[root@server4 ~]# dockerd -D -H tcp:127.0.0.1:2376
```

可以将启动参数写入/etc/docker/daemon.json内,由dockerd服务启动时读取.注意不能同启动配置文件有同样的配置项,否则启动会报错.

```sh
[root@server4 ~]# vi /etc/docker/daemon.json
{
        "debug": true,
        "hosts": ["tcp://127.0.0.1:2376"]
}
```

也可以修改文件/usr/lib/systemd/system/docker.service中ExecStart后面的参数来配置启动参数:

```sh
[root@server1 ~]# vi /usr/lib/systemd/system/docker.service 
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://192.168.2.234:5999
[root@server1 ~]# systemctl daemon-reload
[root@server1 ~]# systemctl restart docker
```



## 仓库配置

在从Docker Hub下载慢的情况下,可以配置镜像仓库:

```sh
    "registry-mirrors": [
        "https://mirror.ccs.tencentyun.com",
        "http://docker.mirrors.ustc.edu.cn",
        "https://5ifniqg5.mirror.aliyuncs.com",
        "https://registry.docker-cn.com",
        "http://hub-mirror.c.163.com",
        "https://mirror.ccs.tencentyun.com"
        ],
```

自建的私有仓库一般不会设置TLS,需要把仓库地址添加到信任列表:

```sh
    "insecure-registries": [
        "192.168.2.241:5000",
        "192.168.2.234:5999"
        ],
```



## 安全配置

Docker Daemon监听Socket有三种方式,分别是unix,tcp和fd.

默认配置中,Docker Remote API通过Socket监听来自本地的连接,监听地址位于unix:///var/run/docker.sock.可以通过curl发送一个简单的请求来测试:

```sh
[root@server4 ~]# curl --unix-socket /var/run/docker.sock http://localhost/info
{"ID":"7YVL:YG7U:BI3Q:BOVZ:XRWD:7BQO:6H3R:2BUW:OCQO:7JKZ:2OWC:UL2Q","Containers":5,"ContainersRunning":4,"ContainersPaused":0,"ContainersStopped":1,"Images":22,"Driver":"
```

可以通过-H选项来修改监听方式:

```sh
[root@server1 ~]# dockerd -H 192.168.2.234:5999 -H unix:///var/run/docker.sock &
```

客户端可以通过docker -H指定服务端地址,来操作服务端:

```sh
[root@server4 ~]# docker -H tcp://192.168.2.234:5999 pull ubuntu
```

在Docker中规定2375作为非加密端口,2376作为加密端口.如果没有启动tls,则服务端与客户端的通信没有认证和加密,任何客户端口可以向服务端发送命令.

使用TLS通信需要在服务端和客户端中加入TLS相关的配置.首先创建RSA私钥ca.key:

```sh
[root@server1 ~]# openssl genrsa -aes256 -out ca.key 4096
Generating RSA private key, 4096 bit long modulus
..................................................................++
..................++
e is 65537 (0x10001)
Enter pass phrase for ca.key:
Verifying - Enter pass phrase for ca.key:
```

使用RSA私钥创建CA证书ca.pem.参数-x509是生成自签名CA证书,参数-days 365设置证书有效期:

```sh
[root@server1 ~]# openssl req -new -x509 -days 365 -key ca.key -sha256 -out ca.pem
Enter pass phrase for ca.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [XX]:CN
State or Province Name (full name) []:BeiJing
Locality Name (eg, city) [Default City]:BeiJing
Organization Name (eg, company) [Default Company Ltd]:server1
Organizational Unit Name (eg, section) []:Dev
Common Name (eg, your name or your server's hostname) []:server1
Email Address []:root@server1.com
[root@server1 ~]# scp ca.* root@192.168.2.241:/root
root@192.168.2.241's password: 
ca.key                                                 100% 3326     2.7MB/s   00:00    
ca.pem                                                 100% 2094     2.4MB/s   00:00    
ca.srl                                                 100%   17    24.3KB/s   00:00
```

创建服务器私钥和CSR.其中server.key是服务器公钥的文件名,server.csr是服务器CSR文件名:

```sh
[root@server1 ~]# openssl genrsa -out server.key 4096
Generating RSA private key, 4096 bit long modulus
................++
............................................................................................................................................................................................................................................++
e is 65537 (0x10001)
[root@server1 ~]# openssl req -subj "/CN=server1" -sha256 -new -key server.key -out server.csr
```

使用CA证书创建服务器证书文件,可以限制连接客户端IP:

```sh
[root@server1 ~]# echo subjectAltName = IP:192.168.2.234,IP:192.168.2.241,IP:127.0.0.1 > allowip.cnf
[root@server1 ~]# openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out server.pem -extfile allowip.cnf
Signature ok
subject=/CN=server1
Getting CA Private Key
Enter pass phrase for ca.key:
```

创建客户端私钥和CSR:

```sh
[root@server4 ~]# openssl genrsa -out client.key 4096
Generating RSA private key, 4096 bit long modulus
................................................................................................................................................................................................................................................++
...............................................................................................................++
e is 65537 (0x10001)
[root@server4 ~]# openssl req -subj '/CN=server4' -new -key client.key -out client.csr
```

使用CA证书创建客户端证书文件,需要加入extendedKeyUsage选项:

```sh
[root@server4 ~]# echo extendedKeyUsage = clientAuth > client.cnf
[root@server4 ~]# openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca.key -CAcreateserial -out client.pem -extfile client.cnf 
Signature ok
subject=/CN=server4
Getting CA Private Key
Enter pass phrase for ca.key:
```

创建PEM文件之后可以删除CSR文件.修改证书权限并移动到~/.Docker/下面:

```sh
[root@server4 ~]# rm -f client.cnf client.csr 
[root@server4 ~]# chmod -v 0400 *.key
mode of ‘ca.key’ changed from 0644 (rw-r--r--) to 0244 (r--r--r--)
mode of ‘client.key’ changed from 0644 (rw-r--r--) to 0244 (r--r--r--)
[root@server4 ~]# chmod -v 0444 *.pem
mode of ‘ca.pem’ changed from 0644 (rw-r--r--) to 0444 (r--r--r--)
mode of ‘client.pem’ changed from 0644 (rw-r--r--) to 0444 (r--r--r--)
[root@server4 ~]# mkdir .docker
[root@server4 ~]# cp ca.pem client.* .docker/
[root@server1 ~]# rm -f server.csr allowip.cnf 
[root@server1 ~]# chmod -v 0400 *.key
mode of ‘ca.key’ changed from 0644 (rw-r--r--) to 0244 (r--r--r--)
mode of ‘server.key’ changed from 0644 (rw-r--r--) to 0244 (r--r--r--)
[root@server1 ~]# chmod -v 0444 *.pem
mode of ‘ca.pem’ changed from 0644 (rw-r--r--) to 0444 (r--r--r--)
mode of ‘server.pem’ changed from 0644 (rw-r--r--) to 0444 (r--r--r--)
[root@server1 ~]# mkdir .docker
[root@server1 ~]# cp ca.pem server.* .docker/
```

修改服务端配置文件并重启:

```sh
[root@server1 ~]# vi /etc/docker/daemon.json
{
    "tlsverify": true,
    "tlscacert": "/root/.docker/ca.pem",
    "tlscert": "/root/.docker/server.pem",
    "tlskey": "/root/.docker/server.key"
}
[root@server1 ~]# systemctl restart docker
```

修改客户端配置文件并重启:

```sh
[root@server4 ~]# vi /etc/docker/daemon.json
{
    "tlsverify": true,
    "tlscacert": "/root/.docker/ca.pem",
    "tlscert": "/root/.docker/client.pem",
    "tlskey": "/root/.docker/client.key"
}
[root@server4 ~]# systemctl restart docker
```

客户端测试连接:

```sh
[root@server4 ~]# docker --tlsverify --tlscacert=ca.pem --tlscert=client.pem --tlskey=client.key -H tcp://192.168.2.234:5999 ps -a
CONTAINER ID   IMAGE           COMMAND           CREATED       STATUS                      PORTS     NAMES
7198e1cdf396   pytest/volume   "/bin/sleep 60"   5 hours ago   Exited (0) 5 hours ago                clever_aryabhata
```

